#+OPTIONS: ^:nil TOC:2
#+TITLE: LLVM Language Reference Manual

#+BEGIN_HTML
---
layout: post
title: LLVM Language Reference Manual
category: research
tags:
- llvm
- note
---
#+END_HTML

* Abstract
** LLVM is a Static Single Assignment (SSA) based representation that provides type safety, low-level operations, flexibility, and the capability of representing ‘all’ high-level languages cleanly. 
** the common code representation used throughout all phases of the LLVM compilation strategy.
* Introduction
** 3 code representation forms of llvm IR:
***  in-memory compiler IR
***  on-disk bitcode representation _.bc_ file,for fast loading by JIT compiler
***  human readable _.ll_
llvm-dis and llvm-as can be use to transfer from/to bitcode files

** Well-Formedness
- Syntactically-ok \neq well-formed. 
~%x = add i32 1, %x~ is not well-form since the definition of ~%x~ does not dominate all of its uses.
- LLVM provides a verification pass to check well-formedness(see ~llvm/Analysis/Verifier.h~ and ~lib/VMCore/Verifier.cpp~ and its usage in ~examples/Kaleidoscope~.

* Identifiers
** 2 identifier types:
*** Global(~GlobalValue~):begin with _@_
*** Local(register names, types):begin with _%_
** 3 formats:
*** Named values: ~[%@][a-zA-Z$._][a-zA-Z$._0-9]*~
Identifier which require other character in their names can be surrounded with quotes; special characters may be escaped using "\xx"
*** Unnamed values(temporary): an unsigned numeric value,~[%@][0-9]+~
*** Constants

* High Level Structure
** Module Structure
*** Module \rightarrow translation unit
**** functions
**** global variables
**** symbol table entries
*** LLVM linker links modules
**** merge functions and global variables
**** resolve forward declarations
**** merge symbol table entries

#+BEGIN_SRC llvm
; Declare the string constant as a global constant.
@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"
; External declaration of the puts function
declare i32 @puts(i8* nocapture) nounwind
; Definition of main function
define i32 @main() {   ; i32()*
  ; Convert [13 x i8]* to i8  *...
  %cast210 = getelementptr [13 x i8]* @.str, i64 0, i64 0
  ; Call puts function to write out the string to stdout.
  call i32 @puts(i8* %cast210)
  ret i32 0
}
; Named metadata
!1 = metadata !{i32 42}
!foo = !{!1, null}
#+END_SRC

** Linkage Types
~GlobalValue~ has one of the following types of linkage
*** private
**** only directly accessible by objects in current module
**** linking code into a module with private global value may cause privateto be renamed to avoid collisions
**** all references can be updated
**** doesn't show up in any symbol table in the object file
*** linker_private
**** similar to ~private~
**** symbol is passed through the assembler and evaluated by the linker
**** remove by the linker from final linked image(executable/dynamic shared library)
*** linker_private_weak
**** similar to ~linker_private~
**** symbol is weak
**** TODO coalescing by the linker
**** removed by the linker from the final linked image
*** internal
**** similar to ~private~
**** the value shows a local symbol(*STB_LOCAL* in the case of /ELF/) in object file
**** corresponds to *static* keyword in C.
*** available_externally
**** never emitted into the object file corresponding to module
**** allow inlining and other optimizations to take place given knowledge of the definition of the global(somewhere outside the  module)
**** allow to be discarded at will, otherwise the same as ~linkonce_odr~
**** only allowed on definitions, not declarations
*** linkonce
**** merged with other globals of the same name when linking
**** used to implement some forms of inline functions, templates or other code which must be generated in each translation unit that uses it but the body may be overridden with a more definitive definition
**** unreferenced ~linkonce~ globals are allowd to be discarded
**** does not allow optimizer to inline the body of this function into callers
***** It doesn't know if this definition of the function is the definitive definition within program or whether it will be overridden by a stronger definition
***** use ~linkonce_ord~ linkage instead to enable inlining and other optimizations
*** weak
**** same merging semantics as ~linkonce~ except that unreferenced globals cannot be discarded
**** TODO corresponding to *weak* declared in C
*** common
**** most similar to ~weak~, but used for tentative definitions in C(for instance, ~int X~ at global scope).
**** merged in the same way as ~weak~, and may not be deleted if unreferenced.
**** may not have an explicit section, must have a zero initializer, may not marked *constant*
**** Functions and aliases may not have ~common~ linkage
*** appending
**** may only be applied to global variables of pointer to array type
**** two global arrays with ~appending~ linkage are appended when linked
*** exern_weak
**** the symbol is weak until linked; otherwise becomes null instead of being an undefined reference.
**** follow ELF object file model
*** linkonce_odr, weak_odr
**** ODR -> one definition rule
**** additionally ensure that the global will only be merged with equivalent globals
*** linkonce_odr_auto_hide
**** similar to ~linkonce_odr~, but nothing in translation until takes the address of this definition. For instance, functions has an inline definition, but the compiler decided not to inline
**** have only ~default~ visiblity
**** removed by linker from final linked image
*** external
**** default linkage
**** participates in linkage and can be used to resolve external symbol references
*** Windows-only linkage types: ~dllimport~ , ~dllexport~

** Calling Conventions
LLVM _functions_, _calls_ and _invokes_ can all have an optional calling convention specified for the call. The calling convention of any pair of dynamic caller/callee must match
*** ccc - the C calling convention
**** default calling convertion, matches C calling conventions
**** supports varargs function calls and tolerates some mismatch in the declared prototype and implemented declaration of the function
*** fastcc - the fast calling convention
**** attempt to make calls as fast as possible(e.g. by passing things in registers)
**** allow target to use whatever tricks it wants to produce fast code for the target, without conforming to an externally specified ABI
**** tail calls can only be optimized when ~fastcc~, ~cc 10~ or ~cc 11~ is used.
**** do not support varargs and requires exact match between prototype and definition
*** codecc - the code calling convention
**** attempt to make code in the caller as efficient as possible under the assumption that the call is not commonly executed
**** often all registers so that call does not break any live ranges in the caller side
**** do not support varargs and requires exact match between prototype and definition
*** cc 10 - GHC convention
**** for use of Glasgow Haskell Compiler(GHC)
**** pass everything in registers, going to extremes to achieve this by disabling callee save registers
**** should not be used lightly but only for specific situations such as an alternative to the /register pinning/ performance technique used in FP languages
**** only X86 support this convention and has following limitations:
***** X86-32 only supports up to 4 bit type parameters, no FT types support
***** X86-64 only supports up to 10 bit type parameters, 6 FP parameters
**** support tail call optimization but requires BOTH caller and callee are using it
*** cc 11 - the HiPE calling convention
**** for use of High-Performance Erlang(HiPE)
**** use more registers for argument passing than cc and defines no callee-save registers
**** support tail call optimizations but requires BOTH caller and callee are using it
**** use /register pinning/ mechanism for keeping frequently accessed runtime componnets pinned to specific hardware registers
**** only X86 support
*** cc <n> - Numbered convention
**** Any calling convention may be specified by number, allowing target-specific calling convention
** Visibility Styles
All global variables and functions have one of the 3 visibility styles:
*** default
**** targets using ELF
***** declaration is visible to other moudules
***** in shared libraries, declared entity may be overridden
**** Darwin: declaration is visible to other modules
**** correspond to ~external linkage~
*** hidden
**** two declarations of an object with hidden visibility refer to the same object if in same shared object
**** symbol will not be placed into dynamic symbol table, and no other module(executable or shared library) can reference it directly
*** protected
**** On ELF
***** will be placed in the dynamic symbol table
***** reference within hte defining module will bind to local symbol(cannot be overridden by another module)
** Named Types
*** name aliases for certain types except ~void~
#+BEGIN_SRC llvm
%mytype = type { %mytype*, i32}
#+END_SRC
*** can specify multiple names for the same type, but LLVM IR printer would pick ONE name
** Global Variables
define regions of memory allocated at COMPILATION time instead RUNTIME
*** may be initialized, may have an explicit section to be placed in, may have exptional explicit alignment specified
*** may be defined as ~thread_local~, meaning that each thread will have a separated copy of the variable(not all targets support ~thread_local~ variables)
**** TODO a TLS model may be specified
***** localdynamic: variables that are only used within current shard library
***** initialexec: variables in modules that will not be loaded dynamically
***** localexec: variables defined in the executable and only used within it
*** may be defined as global ~constant~, indicating the content will NEVER be modified(for optimization)
**** variables needing runtime initialization cannot be marked as constant
**** *declarations* of global variables are allow to be marked constant even if the final definition of the global is not. Require language def to guarantee that optimizations based on the constantness are valid for the translation units that do not include the definition
*** As SSA values, global variables always define a pointer to their content type, and are in all basic blocks in the program
ALL memory objects in LLVM are accessed through POINTERS.
*** can be marked with ~unnamed_addr~, indicating that the address is not significant(only the content); can be merged with other constatns when  they share the same initializer. A ~constant~ with significant address can be merged with ~unnamed_addr constant~, the result being a constant whose address is significant.
*** may be declared to reside in a target-specific numbered address
**** default address space is 0
**** address space qualifier must PRECEDE other attributes
*** explicit section speified for *GLOBALS* (variables, functions) is allowed; then LLVM will emit globals to the section.
*** By default, global initializer are optimized by assuming that global variables defined within module are not modified from their values before the start of global initializer; the assumption would be suppressed by marking variable with ~externally_initialized~.
*** an explicit alignment may be specified, which is a power of 2; 0 by default(set by target).
#+BEGIN_SRC llvm
;; numbered address 5, 
@G = addrspace(5) constant float 1.0, section "foo", align
@G = thread_local(initialexec) global i32 0, align 4
#+END_SRC
** Functions
*** see ~include/llvm/Function.h~
**** ~Argument(llvm/Argument.h)~,
**** ~BasicBlock~, forming CFG.
**** ~SymbolTable(llvm/ValueSymbolTable.h)~
*** syntax
**** definition
#+BEGIN_SRC llvm
define [linkage] [visibility]
[cconv] [unnamed_addr][ret attrs]
<ResultType> @<FunctionName> ([argument list])
[fn Attrs] [section "name"] [align N]
[gc] { ... }
#+END_SRC
**** declaration
#+BEGIN_SRC llvm
declare [linkage] [visibility]
[cconv] [unnamed_addr] [ret attrs]
<ResultType> @<FunctionName> ([argument list])
[align N] [gc]
#+END_SRC
*** Basicblock 
**** may optionally start with a label(giving the basic block a SYMBOL TABLE)
**** contain a list of instructions and end with ~terminator~
**** first basic block is special:
***** immediately executed on entrance to function
***** not allowed to have predecessor; cannot have PHI node
** Aliases
*** second name for function, global variable, another alias, bitcast of global value
*** may have ~linkage type~ or ~visibility style~
*** syntax
#+BEGIN_SRC llvm
@<Name> = alias [Linkage] [visibility] <AliaseeTy> @<Aliasee>
#+END_SRC

** Named Metadata
*** ~llvm/Metadata.h~, ~Metadata.cpp~
*** a collection of metadata
*** dbg metadata can be seen [[http://llvm.org/docs/SourceLevelDebugging.html*debugging-information-format][here]]
*** operands: metadata node(not metadata strings)
*** syntax
#+BEGIN_SRC llvm
!0 = metadata !{metadata !"zero"}
!1 = metadata !{metadata !"one"}  ;unnamed metadata nodes
!name = !{!0, !1} ; A named metadata
#+END_SRC

** Parameter Attributes
*** ~llvm/Attributes.h~, ~FunctionType~, ~llvm/DerivedTypes.h~
*** OWNER: 
**** function return type(*FunctionType.getReturnType()*)
**** parameter of a function type(*FunctionType.getParamType(i)*)
*** part of FUNCTION, not function type
**** function with different parameter attributes CAN have the same function type
#+BEGIN_SRC llvm
declare i32 @printf(i8* noalias nocapture, ...)
declare i32 @atoi(i8 zeroext)
declare signext i8 @returns_signed_char()
#+END_SRC
*** zeroext
**** parameter or return value should be zero-extended to the extent rquired by target's ABI(usally 32-bits, 8-bits for i1 on x86-64) by caller(parameter) or callee(return value)
*** singext
**** sign-extended
*** inreg
**** treated in a special TARGET-DEPENDENT fashion while emitting code for function call or return(usually put into a register).
*** byval
**** The pointer parameter should be passed by value to function, a hidden copy of pointee is made between caller and callee(so callee cannot modify value in caller)
**** only used for LLVM pointer arguments, not valid for return values
**** the copy belongs to caller, soj readonly functions should not write to ~byval~ parameters
**** allow an alignment with align attribute; target-specific if not specified
*** sret
**** indicate the pointer parameter specifies the address of a structure that is the return value of function in source program.
**** This pointer must be guaranteed by caller to be valid: loads and stores to the structure may be assumed by callee not to trap and to be properly aligned.
**** only applied to the FIRST PARAMETER; not valid for return values
*** noalias
**** TODO indicate pointer values /based <pointeraliasing>/ on argument or return value don't alias pointer values which are not *based* on, ignoring certain irrelevant dependencies.[[http://llvm.org/docs/AliasAnalysis.html#MustMayNo][alias analysis]]
**** similar to ~restrict~ keyword in C99 but slightly weaker(~restrict~ cannnot be used for return values)
*** nocapture
**** callee doesn't make copies of the pointer that outlive callee
**** not valid for return values
*** nest
**** pointer parameter can be excised ~trampoline intrinsics~
**** not valid for return values; can only be applied to ONE parameter
*** returned
**** always returns the value of the parameter as its return value
**** allow tail call optimization and omission of register saves and restores, not checked or enforced
**** parameter and function return type must be valid operands for ~bitcast instruction~
**** not valid for return values and can only be applied to ONE parameter

** Garbage Collector Names
#+BEGIN_SRC llvm
define void @f() gc "name" { ... }
#+END_SRC
** Attribute Groups
*** groups of attributes referenced by objects within IR, important for keeping *.ll* readable, module-level
*** object references attribute group's ID; attributes are merged if an object refers to >1 attribute groups
#+BEGIN_SRC llvm
; Target-independent attributes:
attributes #0 = { alwaysinline alignstack=4 }
; Target-dependent attributes:
attributes #1 = { "no-sse" }
; Function @f has attributes: alwaysinline, alignstack=4, and "no-sse".
define void @f() #0 #1 { ... }
#+END_SRC
** Function Attributes
*** part of FUNCTION, not of function type; functions with different function attributes can have the same function type
#+BEGIN_SRC llvm
define void @f() alwaysinline optsize { ... }  ;
#+END_SRC
*** alignstack(<n>)
**** the backend should forcibly align the stack pointer when emitting prologue and epilogue.
*** alwaysinline
**** inliner should attempt to inline function into callers whenever possible ignore any active inlining size threshould for this caller.
*** nonlazybind
**** suppress lazy symbol binding for function
**** make calls to function faster, at cost of extra program startup time if function is not called during program startup
*** naked
**** disable prologue or epilogue emission for function, SYSTEM-SPECIFIC
*** nobuiltin
**** callee function at a call site is not recognized as built-in functions and LLVM would retain the original call
**** only valid at call site, not function declaration or definition
*** noduplicate
**** calls to the function cannot be duplicated
**** call to it may be moved within parent function, but cannot be duplicated within parent function
**** function containing a ~noduplicate~ call may still be inline, implying that the function has ~internal linkage~ and only has one call site
*** noimplicitfloat
**** disable implicit FP instructions
*** noinline
**** indicate the inliner should never inline function in any situation
*** TODO noredzone
**** don't use a red zone even if the target-specific ABI permits
*** noreturn
**** indicate the function never returns normally
**** undefined behavoir at runtime if the function does dynamically return
*** nounwind
**** indicate the function never returns with an unwind or exceptional control flow; undefined if does unwind
*** optsize
**** keep the code size of the function low otherwise do optimizations specifically to reduce code size
*** readone
**** indicate the function computes its result(or decides to unwind an exception) based strictly on its arguments, without dereferencing any pointer arguments or otherwise accessing any mutable state(memory, registers, etc) visible to the caller
**** do not write through ANY pointer arguments(including ~byval~ arguments) and never changes any state visible to callers.
**** cannot unwind exceptions by calling C++ exception throwing methods.
*** returns_twice
**** indicate that the function can return twice(for instance, *setjump* in C)
**** disable some optimizations in the caller of the function
*** sanitize_address
**** ~AddressSanitizer~ checks(dynamic address safety analysis) are enabled
*** sanitize_memory
**** MemorySanitizer checks(dynamic detection of accesses to uninitialized memory) are enabled
*** sanitize_thread
**** ThreadSanitizer checks(dynamic thread safety analysis) are enabled
*** ssp - stack smashing protector
**** the function should emit a stack smashing protector
**** uses a random value placed on the stack before local variables that's checked upon return from the function to see whether it has been overwritten
**** A heuristic is used to determine if a function needs ssp or not, the following functions would be protected:
***** character arrays larger than ssp-buffer-size(default 8)
***** aggregates containing character arrays larget than ssp-buffer-size
***** calls to alloca() with variable size or constant sizes greater than ssp-buffer-size
***** the resultant "caller" function would be ssp if the ssp "callee" is inlined
*** sspreq
**** *always* emit a stack smashing protector, overrides ~ssp~
**** the resultant "caller" function would have ~sspreq~ if the original caller is not ~sspreq~ or ~ssp~ or ~sspstrong~ but the callee has an ~sspreq~
*** sspstrong
**** similar to ~ssp~, but the heuristic is stronger; overrides ~ssp~
**** heuristics to protect functions with:
***** arrays of any size and type
***** arrgregates containing an array of any size and type
***** calls to alloca()
***** local variables that have had their address taken
***** the resultant "caller" function would be ~sspstrong~ if the ~sspstrong~ "callee" is inlined
*** uwtable
**** ABI being targeted requires that an ~unwind~ table entry be produced for this function even if it is ensured that no exceptions passed by it.
**** normally the case for the ELF x86-64 abi, can be disabled for some compilation units
** Module-Level Inline Assembly
*** corresponding to GCC "file scope inline asm"
*** internally concatenated by LLVM and treated as a single unit, but may be separated in
*** The strings can contain ANY character by escaping non-printable chars *\xx*; and would be printed to machine code *.s* file when assembly is generated
#+BEGIN_SRC llvm
module asm "inline asm code goes here"
#+END_SRC
** Data Layout
#+BEGIN_SRC llvm
target datalayout = "layout specification"
#+END_SRC
*** SPECS
**** a list of specifications separated by *-*
**** each starts with a letter, might include other info
*** accepted SPECS
**** *E* big-endian
**** *e* little-endian
**** *S<size>* natural alignment of the stack in bits, multiple of 8-bits; defaults to "unspecified"(does not prevent any alignment promotions) if omitted
**** *p[n]:<size>:<abi>:<pref>* *size* (in bits) of a pointer and its *abi* and *pref* erred alignments for address space *n*. If *n* not specified, defaults to address space 0; n \in [1,2^23)
**** *i<size>:<abi>:<pref>* alignment for an integer type
**** *v<size>:<abi>:<pref>* alignment for vector type
**** *f<size>:<abi>:<pref>* alignment for FP. Only values of *size* that are supported by the target will work. 32 and 64 are supported on ALL targets; 80 or 128 are also supported on SOME targets.
**** *a<size>:<abi>:<pref>* alignment for an aggregate type
**** *s<size>:<abi>:<pref>* alignment for a stack object
**** *n<size1>:<size2>:<size3>...* a set of native integer widths for target CPU in bits. Elments of this set are considered to support most general arithmetic operations efficiently.
*** default SPECS:
**** E - big endian
**** p:64:64:64 - 64-bit pointers with 64-bit alignment
**** p1:32:32:32 - 32-bit pointers with 32-bit alignment for address space 1
**** p2:16:32:32 - 16-bit pointers with 32-bit alignment for address space 2
**** i1:8:8 - i1 is 8-bit (byte) aligned
**** i8:8:8 - i8 is 8-bit (byte) aligned
**** i16:16:16 - i16 is 16-bit aligned
**** i32:32:32 - i32 is 32-bit aligned
**** i64:32:64 - i64 has ABI alignment of 32-bits but preferred alignment of 64-bits
**** f32:32:32 - float is 32-bit aligned
**** f64:64:64 - double is 64-bit aligned
**** v64:64:64 - 64-bit vector is 64-bit aligned
**** v128:128:128 - 128-bit vector is 128-bit aligned
**** a0:0:1 - aggregates are 8-bit aligned
**** s0:64:64 - stack objects are 64-bit aligned
*** Determining rules:  
****  exact match - OK
****  no match, integer type - smallest larger integer type,or largest integer type if sought type bitwidth is larger than any given
****  no match,vector type - largest smaller vector type
*** If specified, the target data layout is required to match what the ultimate *code generator* expects.
** Pointer Aliasing Rules
*** Pointer values are associated with an address ranges according to these rules:
**** associated with the addresses associated with any value it is based on.
**** An address of a global variable is associated with the address range of the variable’s storage.
**** The result value of an allocation instruction is associated with the address range of the allocated storage.
**** A null pointer in the default address-space is associated with no address.
**** An integer constant other than zero or a pointer value returned from a function not defined within LLVM may be associated with address ranges allocated through mechanisms other than those provided by LLVM. Such ranges shall not overlap with any ranges of addresses allocated by mechanisms provided by LLVM.

*** A pointer value is based on another pointer value:
**** A pointer value formed from a ~getelementptr~ operation is based on the first operand of the getelementptr.
**** The result value of a bitcast is based on the operand of the bitcast.
**** A pointer value formed by an inttoptr is based on all pointer ~values~ that contribute (directly or indirectly) to the computation of the pointer's value.
**** The "based on" relationship is transitive.
*** Notes
****  ~based~ is similar to C99 _based_ but weaker
****  LLVM IR does not associate types with memory
****  type-based alias analysis(TBAA, ~-fstrict-aliasing~) is not applicable to general unadorned LLVM IR,needing ~metadata~

** Volatile Memory Accesses
*** ~load~, ~store~ and ~llvm.memcpy~ may be marked *volatile*.
*** optimizers must not change order of volatile relative to other volatile operations, but can chnge order relative to non-volatile operations
*** different from Java's volatile and has no cross-thread synchronization
*** IR level volatile ~load~ and ~store~ cannot safely be optimized into ~llvm.memocpy~ or ~llvm.memmove~ even when those intrinsics are flagged volatile; the backend should never split or merge target-legal volatile ~load~ / ~store~ .
#+BEGIN_QUOTE 
  Platforms may rely on volatile loads and stores of natively supported data width to be executed as single instruction. For example, in C this holds for an l-value of volatile primitive type with native hardware support, but not necessarily for aggregate types. The frontend upholds these expectations, which are intentionally unspecified in the IR. The rules above ensure that IR transformation do not violate the frontend’s contract with the language.
#+END_QUOTE
** Memory Model for Concurrent Operations
*** LLVM IR doesn't define ANY way to start parallel threads of execution or to register signal handlers, but platform-specific approaches are available(similar to C++0x memory model).
*** see [[LLVM Atomic Instructions and Concurrency Guide][http://llvm.org/docs/Atomics.html]] for more information
** Atomic Memory Ordering Constraints
** Fast-Math Flags
* Type System
** Type Classifications

| Classification | Types                                                         |
|----------------+---------------------------------------------------------------|
| primitive      | label, void, _floating point_, x86mmx, metadata.              |
| derived        | _integer_,array, function, pointer, structure, vector, opaque |

*** ~llvm/Type.h~, ~llvm/DerivedTypes.h~; in llvm-3.3, they are put in ~llvm/IR~
*** every ~Value~ in llvm has a ~Type(Value.getType())~
*** _FirstClassType_: the only ones which can be produced by instructions,valid type for a Value; all types except ~function/void/opaque~
*** _SingleValueType_: valid type for a virtual register in codegen,first-class type except struct/array
*** _Sized_:primitive types except ~VoidTy~(whose size is 0) or concrete ~Struct/Array/Vector~

** Primitive Types
*** Integer Type  
#+BEGIN_SRC llvm
;Syntax:
iN  (N is in [1,2^23 -1])
;Examples:
i1            #a single-bit integer.
i32           #a 32-bit integer.
i1942652      #a really big integer of over 1 million bits.
#+END_SRC
*** Floating Point Types
| Type      | Description               |
|-----------+---------------------------|
| half      | 16-bit(not in llvm2.9)    |
| float     | 32-bit                    |
| double    | 64-bit                    |
| fp128     | 128-bit(112-bit mantissa) |
| x86_fp80  | 80-bit(X87)               |
| ppc_fp128 | 128-bit(two 64-bits)      |
*** X86mmx Type
**** represents a value held in an MMX register on an x86 machine
**** allowed operations: parameters and return values, load and store, bitcast.
*** Void Type
does not represent any value and has not type.
*** Label Type
represent code labels
*** Metadata Type
**** represents embedded metadata
**** no derived types may be created from metadata except for ~function~ arguments
** Derived Types
There's some tricks on [[http://llvm.org/docs/ProgrammersManual.html#the-type-class-and-derived-types][Programmer's manual]] for important derived types.
*** Aggregate Types
**** derived types containing multiple member types
**** ~array~ and ~structs~ are aggregate types, but ~vector~ is not
***  Array Type  
single-dimension ~variable sized array~ addressing can be implememted in LLVM with zero length array type.
#+BEGIN_SRC llvm
[<# elements> x <elementtype>]
[41 x i32]            ; Array of 41 32-bit integer values.
[12 x [10 x float]]   ; 12x10 array of single precision floating point values.
[2 x [3 x [4 x i16]]] ; 2x3x4 array of 16-bit integer values.
#+END_SRC
***  Function Type
Function signature. 
**** return type(first class type or void, any type except ~label~)
**** list of formal parameter types, might include a type ..., indicating a variable number of arguments(handled by ~variable argument handling intrinsic~)
#+BEGIN_SRC llvm
<returntype> (<parameter list>)
i32 (i8, ...) ;; printf signature in LLVM
float (i16, i32 *) *
{i31, i234}(float)
#+END_SRC

***  Structure Type 
Elements type:all but ~void~(having _size_), structures in registers are accessed using ~extractvalue~ and ~insertvalue~ instructions
_literal_ or __identified__/__packed__ or __unpacked__

| Type       | recusive | opaque | remark                                        |
|------------+----------+--------+-----------------------------------------------|
| literal    | no       | no     | defined inline with other types ({i32, i32}*) |
| identified | yes      | yes    | always defined at the top level with a name   |

| Type     | layout                          |
|----------+---------------------------------|
| packed   | alignment: 1 byte;no padding    |
| unpacked | padding defined by ~DataLayout~ |

#+BEGIN_SRC llvm
;Syntax:
%T1 = type { <type list> }     ; Identified normal struct type
%T2 = type <{ <type list> }>   ; Identified packed struct type
;Examples:
{ i32, i32, i32 }              ; A triple of three i32 values
{ float, i32 (i32) * }         
<{ i8, i32 }>                  ; A packed struct known to be 5 bytes in size.
#+END_SRC

*** Opaque Structure Types
named structure types that do not have a body specified
#+BEGIN_SRC llvm
 %X = type opaque
#+END_SRC

*** Pointer Type
**** memory locations, mainly used to reference objects in memory.
**** may have an optional address space attribute defining the numbered address space(target-specific,default=0) where the pointed-to object resides.
**** LLVM does not permit pointers to _void_ (void*) nor does it permit pointers to _labels_ (label*).

#+BEGIN_SRC llvm
[4 x i32]*       ; A pointer to array of four i32 values.
i32 (i32*) *     ; A pointer to a function that takes an i32*, returning an i32.
i32 addrspace(5)* ; A pointer to an i32 value that resides in address space #5.
#+END_SRC

*** Vector Type
used in SIMD
#+BEGIN_SRC llvm
; Syntax:
< <# elements> x <elementtype> > 
; Examples:
<2 x i64>   ; Vector of 2 64-bit integer values.
<4 x i64*>  ; Vector of 4 pointers to 64-bit integer values.
#+END_SRC
* Constants
** Simple Constants
No constants of type x86mmx
*** Boolean constants: ~true~ and ~false~
*** Integer constants
*** Floating point constants
Assembler requires the _exact_ decimal value of a FP constant(for this reason, 1.3 is rejected and 1.25(1.01b) is accepted)
*** Null pointer constants
** Complex Constants
*** Structure constants
must have ~structure type~; number and types of elements must match those specified by the type
#+BEGIN_SRC llvm
@G = external global i32
{i32 4, float 17.0, i13* @G}
#+END_SRC
*** Array constants
#+BEGIN_SRC llvm
[i32 42, i32 11, i32 74]
#+END_SRC
*** Vector constants
#+BEGIN_SRC llvm
< i32 42, i32 11, i32 74, i32 100 >
#+END_SRC
*** Zero initialization
~zeroinitializer~ to initialize a value to zero of any type, including ~scalar~ and aggregate types.
*** Metadata node
#+BEGIN_SRC llvm
metadata !{i32 0, metadata !"test"}
#+END_SRC
** Global Variable and Function Addresses
The *addresses* of global variables and functions are ALWAYS implicitly valid linke-time constants, having pointer types
#+BEGIN_SRC llvm
@X = global i32 17
@Y = global i32 42
@Z = global [2 x i32 *] [i32 * @X, i32 * @Y]
#+END_SRC
** Undefined Values
*** ~undef~ can be used anywhere a *constant* of any type is expected
*** indicating that the user of value may receive an unspecified bit-pattern
** Poison Values
*** similar to ~undef~; also represent the fact that an instruction or constant expression which cannot evoke side effects has nevertheless detected a condition which results in undefined behavior.
*** no way of representing a poison value in the IR, only existing when produced by operations like ~add~ with ~nsw~ flags
*** poison value behavior is defined in terms of /value dependence/:
**** value other that ~phi~ depend on their operands
**** ~phi~ nodes depend on the operand corresponding to their dynamic predecessor basic block.
**** Function arguments depend on the corresponding actual argument values in the dynamic callers of their functions.
**** ~CallInst~  depend on the ret instructions that dynamically transfer control back to them.
**** Invoke instructions depend on the ret, resume, or exception-throwing call instructions that dynamically transfer control back to them.
**** Non-volatile loads and stores depend on the most recent stores to all of the referenced memory addresses, following the order in the IR (including loads and stores implied by intrinsics such as @llvm.memcpy.)
**** An instruction with externally visible side effects depends on the most recent preceding instruction with externally visible side effects, following the order in the IR. (This includes volatile operations.)
**** An instruction control-depends on a terminator instruction if the terminator instruction has multiple successors and the instruction is always executed when control transfers to one of the successors, and may not be executed when control is transferred to another.
**** Additionally, an instruction also control-depends on a terminator instruction if the set of instructions it otherwise depends on would be different if the terminator had transferred control to a different successor.
**** Dependence is transitive.
*** Poison Values have the same behavior as undef values, with the additional affect that any instruction which has a dependence on a poison value has undefined behavior.
#+BEGIN_SRC llvm
entry:
  %poison = sub nuw i32 0, 1           ; Results in a poison value.
  %still_poison = and i32 %poison, 0   ; 0, but also poison.
  %poison_yet_again = getelementptr i32* @h, i32 %still_poison
  store i32 0, i32* %poison_yet_again  ; memory at @h[0] is poisoned

  store i32 %poison, i32* @g           ; Poison value stored to memory.
  %poison2 = load i32* @g              ; Poison value loaded back from memory.

  store volatile i32 %poison, i32* @g  ; External observation, UB

  %narrowaddr = bitcast i32* @g to i16*
  %wideaddr = bitcast i32* @g to i64*
  %poison3 = load i16* %narrowaddr     ; Returns a poison value.
  %poison4 = load i64* %wideaddr       ; Returns a poison value.

  %cmp = icmp slt i32 %poison, 0       ; Returns a poison value.
  br i1 %cmp, label %true, label %end  ; Branch to either destination.

true:
  store volatile i32 0, i32* @g        ; This is control-dependent on %cmp, so has UB
  br label %end

end:
  ; Both edges into this PHI are control-dependent on %cmp, so this ; always results in a poison value.
  %p = phi i32 [ 0, %entry ], [ 1, %true ]

; This would depend on the store in %true ; if %cmp is true, or the store in %entry otherwise, so UB
  store volatile i32 0, i32* @g        

; The same branch again, but this time the ; true block doesn't have side effects.
  br i1 %cmp, label %second_true, label %second_end

second_true:
  ; No side effects!
  ret void

second_end:
; the instruction always depends on the store in %end. Also, it is control-equivalent to %end, so this is
; well-defined (ignoring earlier undefined behavior in this example).
  store volatile i32 0, i32* @g        
#+END_SRC
** Addresses of Basic Blocks
#+BEGIN_SRC llvm
blockaddress(@function, %block)
#+END_SRC
*** compute the address of specified basic block in specified function
*** has a /i8*/ type
*** illegal to take the address of the entry block
*** used as an operand to the ~indirectbr~ instruction or for comparisons against nul
** Constant Expressions
may be any first class type and may involve any LLVM operation having no side effects
*** trunc (CST to TYPE)
**** sizeof(CST)>sizeof(TYPE)
**** integers
*** zext / sext (CST to TYPE)
**** sizeof(CST) < sizeof(TYPE)
**** integers
*** fptrunc (CST to TYPE)
**** sizeof(CST) > sizeof(TYPE)
**** floating point
*** fpext (CST to TYPE)
**** sizeof(CST) <= sizeof(TYPE)
**** floating point
*** fptoui / uitofp / fptosi / sitofp (CST to TYPE)
**** convert FP constant to / from unsigned signed integer constant
**** TYPE must be a scalar / vector integer type
**** CST must be of scala / vector FP type
**** number of elements must be the same if vectors
*** ptrtoint / inttoptr (CST to TYPE)
**** convert a pointer typed constant to integet constant
**** TYPE must be an integer / pointer type, CST must pointer / integer type
**** CST value is zero extended, truncated, or unchanged
*** bitcast (CST to TYPE)
**** convert CST to TYPE type
**** constraints of the operands are the same as those for ~BitCastInst~
*** getelementptr (CSTPTR, IDX0, IDX1, ...), getelementptr ibounds (CSTPTR, IDX0, IDX1, ...)
**** perform ~GetElementPtrInst~ on constants
**** the index list may have \ge 0 indexes
*** select (COND, VAL1, VAL2)
*** icmp COND (VAL1, VAL2)
*** fcmp COND (VAL1, VAL2)
*** extractelement (VAL, IDX)
*** insertelement (VAL, ELT, IDX)
*** shufflevector (VEC1, VEC2, IDXMASK)
*** extractvalue (VAL, IDX0, IDX1, ...)
*** insertvalue (VAL, ELT, IDX0, IDX1)
*** OPCODE (LHS, RHS)
* Other Values
** Inline Assembler Expressions
#+BEGIN_SRC llvm
%X = call i32 asm "bswap $0", "=r,r"(i32 %Y)
#+END_SRC
*** only used with ~CallInst~ and ~InvokeInst~
*** inline asms with side effects not visible in constraint list
#+BEGIN_SRC llvm
call void asm sideeffect "eieio", ""()
#+END_SRC
*** sometimes inline asms will not work unless the statck is aligned in some way
#+BEGIN_SRC llvm
call void asm alignstack "eieio", ""()
#+END_SRC
*** support for non-standard assembly dialets(ATT and Intel)
#+BEGIN_SRC llvm
call void asm inteldialect "eieio", ""()
#+END_SRC
*** Inline Asm Metadata
#+BEGIN_SRC llvm
call void asm sideeffect "something bad", ""(), !srcloc !42
...
!42 = !{ i32 1234567 }
#+END_SRC
** Metadat Nodes and Metadata Strings
*** ~tbaa~ Metadata
**** memory has no types in LLVM IR, so LLVM's own type system ISN'T sutable for doing TBAA
**** TBAA metadata nodes have up to 3 fields
#+BEGIN_SRC llvm
!0 = metadata !{ metadata !"an example type tree" }
!1 = metadata !{ metadata !"int", metadata !0 }
!2 = metadata !{ metadata !"float", metadata !0 }
!3 = metadata !{ metadata !"const float", metadata !2, i64 1 }
#+END_SRC
***** First, identitity field; any value, usually a metadata string; The name of the root node is IMPORTANT.
***** Second, type's parent node(null / omitted for root node). a type is considered to alias all of its DESCENDANTS and all of its ANCESTORS in the tree; alias all types in OTHER trees, so that bitcode produced from multiple font-ends is handled conservatively.
***** Third, an integer; equal 1 indicating the type is "constant"(~pointsToConstantMemory~ should return true)
*** ~tbaa.struct~ Metadata
**** ~llvm.memcpy~ is used to implemment aggregate assignment operations in C, copying a contiguous region of memory.
**** ~!tbaa.struct~ describes which memory subregions in a mrmcpy are padding and what the TBAA tags of the struct are.
**** Current format:
***** give the type offset of a field in bytes
***** size in bytes
***** tbaa tag
#+BEGIN_SRC llvm
!4 = metadata !{ i64 0, i64 4, metadata !1, i64 8, i64 4, metadata !2 }
#+END_SRC
*** ~fpmath~ Metadata
**** attached to any instruction of FP type
**** TODO express the maximum acceptable error in the result of that instruction, in ULPs; more efficient but less accurate
#+BEGIN_QUOTE 
  ULP:If x is a real number that lies between two finite consecutive floating-point numbers a and b, without being equal to one of them, then ulp(x) = |b - a|, otherwise ulp(x) is the distance between the two non-equal finite floating-point numbers nearest x. Moreover, ulp(NaN) is NaN.
#+END_QUOTE
#+BEGIN_SRC llvm
!0 = metadata !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs
#+END_SRC

** ~range~ Metadata
*** attached to locads of integer types
*** TODO possible ranges the loaded value is in, represented with a flattened list of integers
*** Loaded value is known to be in the union of the ranges defined by each consevutive pair, which has the following properties:
**** The type must match the type loaded by the instruction.
**** The pair a,b represents the range [a,b).
**** Both a and b are constants.
**** The range is allowed to wrap.
**** The range should not represent the full or empty set. That is, a!=b.
#+BEGIN_SRC llvm
%b = load i8* %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1
%c = load i8* %z, align 1, !range !2 ; Can only be 0, 1, 3, 4 or 5
!1 = metadata !{ i8 255, i8 2 }
!2 = metadata !{ i8 0, i8 2, i8 3, i8 6 }
#+END_SRC
** ~llvm.loop~
*** attached to the branch instruction in the loop latch block, guaranteed to be separate for each loop; prefixed with ~llvm.loop~
*** identifier metadata is implemented using a metadata that refers to itself to vavoid merging with any other identifier metadata
#+BEGIN_SRC llvm
!0 = metadata !{metadata !0}
!1 = metadata !{metadata !1}
#+END_SRC
** ~llvm.loop.parallel~ Metadata
*** TODO use to communicate that a loop should be considered a parallel loop.
** ~llvm.mem~ Metadata
used to annotate memory accesses with information
** ~llvm.mem.parallel_loop_access~ Metadata
*** TODO for a loop to be parallel, all of memory accessing instructions in the loop body need to be marked with it.
* Module Flags Metada
** LLVM IR isn's sufficient to transmit information about moudule as a whole; ~llvm.module.flags~ named metadata facilitates this, flags are in form of key-value.
** contains a list of metadata triplets.
*** First, ~behavior~ flag, specifying the behavior when 2 or more modules are merged, and 2 or more metadata with the same ID.
*** Second, ~ID~, may only have ONE flag for each ID(not including entries with the *Require* behavior).
*** Third, the value of the flag.
| value | name         | behavior                                                                                                                                     |
|-------+--------------+----------------------------------------------------------------------------------------------------------------------------------------------|
|     1 | Error        | Emit an error if two values disagree, otherwise the resulting value is that of the operands.                                                |
|     2 | Warning      | Emit a warning if two values disagree. The result value will be the operand for the flag from the first module being linked.                |
|     3 | Require      | Add a requirement that another module flag be present and have a specified value after linking is performed.                                |
|     4 | Override     | Use the specified value, regardless of the behavior or value of the other module; error if both module specifies ~Override~ but value differs |
|     5 | Append       | Append the two values, which are required to be metadata nodes.                                                                             |
|     6 | Appendunique | like ~Append~, but duplicate entries in the second list are dropped                                                                          |
** TODO Objective-C Garbage Collection Module Flags Metadata
** TODO Automatic Linker Flags Module Flags Metadata
* Intrinsic Global Variables
** Notes:
*** LLVM has a number of "magic" global variables that contains data that affect code generation or other IR semantics.
*** All globals of this sort should have a section specified as ~llvm.metadata~.
*** ~llvm.used~ Global Variable
**** Array having appending linkage
#+BEGIN_SRC llvm
@X = global i8 4
@Y = global i32 123
@llvm.used = appending global [2 x i8*] [
   i8* @X,
   i8* bitcast (i32* @Y to i8*)
], section "llvm.metadata"
#+END_SRC
**** used to represent references from inline asms and other things the compiler cannot “see”, and corresponds to “attribute((used))” in GNU C.
*** ~llvm.compiler.used~ Global Variable
**** same as ~llvm.used~ but it only prevents the compiler from touching the symbol
**** rarely used, should not be exposed to source languages
*** ~llvm.global_ctors~ Global Variable
*** ~llvm.global_dtors~ Global Variable
* Instruction Reference
** ~IRBuilder(llvm/IRBuilder.h)~ can be used to create ~Instruction~ and insert them into a BasicBlock,extra instruction properties can be set using mutators of Instruction after been created.

  #+BEGIN_TABLE 
| Classification               | Features                                                           | members                                                                                                                                        |
| Terminator                   | BasicBlock's last instruction,yield a ~void~ Value except ~invoke~ | ret, br, switch, indirectbr, invoke, resume, unreachable                                                                                       |
| Binary                       | two operands => Value(same type)                                   | add,fadd,sub,fsub,mul,fmul,udiv,sdiv,fdiv,urem,srem,frem                                                                                       |
| Bitwise Binary               | do bit-twidding,two operands => Value(same type)                   | shl,lshr,ashr,and,or,xor                                                                                                                       |
| Vector Operations            | target-independent,may need target-specific intrinsics             | extractelement,insertelement,shufflevector                                                                                                     |
| Aggregate Operations         |                                                                    | extractvalue,insertvalue                                                                                                                       |
| Memory Access and Addressing | no mem loc are in SSA form;read,write and allocate mem             | alloca,load,store,store,cmpxchg,atomicrmw,getelementptr                                                                                        |
| Conversion Operations        | take one operand of ty1 yields Value with ty2                      | trunc..to, zext..to, sext..to, fptrunc..to, fpext..to, fptoui..to, fptosi..to, uitofp..to, sitofp..to, ptrtoint..to, inttoptr..to, bitcast..to |
| Other Operations             |                                                                    | icmp,fcmp,phi,select,call,va_arg,landingpad                                                                                                    |
  #+END_TABLE
  
** ReturnInst
*** ~ReturnInst(llvm/instructions.h)~: ~TerminatorInst(llvm/InstTypes.h)~
*** return value must be _firstClassType_ or ~void~
  #+BEGIN_SRC llvm
ret i32 5                       ; Return an integer value of 5
ret void                        ; Return from a void function
ret { i32, i8 } { i32 4, i8 2 } ; Return a struct of values 4 and 2
  #+END_SRC

** BranchInst
*** ~BranchInst~: ~TerminatorInst~
*** [Cond,FalseDest,] TrueDest
#+BEGIN_SRC llvm
;Syntax:
br i1 <cond>, label <iftrue>, label <iffalse>
br label <dest>          ; Unconditional branch
;Example:
Test:
  %cond = icmp eq i32 %a, %b
  br i1 %cond, label %IfEqual, label %IfUnequal
IfEqual:
  ret i32 1
IfUnequal:
  ret i32 0
#+END_SRC

** SwitchInst
*** ~SwitchInst~:~TerminatorInst~
*** used for switch-case, case Value is Constant and wouldn't be reused for another Instruction/Value
*** [TODO:bad API design]
#+BEGIN_SRC llvm
;Syntax:
switch <intty> <value>, label <defaultdest> [ <intty> <val>, label <dest> ... ]
;Example:
%Val = zext i1 %value to i32
switch i32 %Val, label %truedest [ i32 0, label %falsedest ]  ; Emulate a conditional br instruction
switch i32 0, label %dest [ ]  ; Emulate an unconditional br instruction
switch i32 %val, label %otherwise [ i32 0, label %onzero i32 1, label %onone i32 2, label %ontwo ] ; Implement a jump table:
#+END_SRC

** IndirectBrInst
*** ~IndirectBrInst~: ~TerminatorInst~
*** implements an indirect branch to a label within current function, whose address is specified by “address”(derived from a ~BlockAddress(llvm/Constants.h)~)
*** typically implemented with a _jump_ through a register
#+BEGIN_SRC llvm
;Syntax:
indirectbr <somety>* <address>, [ label <dest1>, label <dest2>, ... ]
;Example:
indirectbr i8* %Addr, [ label %bb1, label %bb2, label %bb3 ]
#+END_SRC

** InvokeInst
*** ~InvokeInst~: ~TerminatorInst~
*** cause control to transfer to a specified function(like ~CallInst~)
*** ~ret~:normal, ~resume~:exception
*** ~invoke~ and ~unwind~ is used for exception handler
#+BEGIN_SRC llvm
;Syntax:
<result> = invoke [cconv] [ret attrs] <ptr to function ty> <function ptr val>(<function args>) [fn attrs]
                to label <normal label> unwind label <exception label>
;Example:
%retval = invoke coldcc i32 %Testfnptr(i32 15) to label %Continue
              unwind label %TestCleanup              ; {i32}:retval set
;invoke function Testfnptr(which takes a i32 num 15 and return type is i32) using coldcc, normal=> BB:Continue, or exception=> TestCleanup
#+END_SRC
#+END_SRC

**** ~ccc~ if [cconv] not specified
**** only ~zeroext~, ~signext~, ~inreg~ are available for [ret attrs]
**** ~<ptr to function ty~:signature of the pointer to function value being invoked
**** ~<function ptr val>~:value containing a pointer to a function to be invoked
**** only ~noreturn~, ~nounwind~, ~readonly~, ~readnone~ are available for [fn attrs]

** ResumeInst
*** ~ResumeInst~: ~TerminatorInst~
*** resumes propagation of an existing (in-flight) exception whose unwinding was interrupted with a ~landingpad~ instruction;has no successors
*** <value> must have the same type as the result of any ‘landingpad‘ instruction in the same function
#+BEGIN_SRC llvm
;Syntax:
resume <type> <value>
;Example:
resume { i8*, i32 } %exn
#+END_SRC

** UnreachableInst
*** ~UnreachableInst~: ~TerminatorInst~
*** undefined behavior

** ~add~ Instruction

#+BEGIN_SRC llvm
;Syntax:
<result> = add <ty> <op1>, <op2>          ;yields {ty}:result
<result> = add nuw <ty> <op1>, <op2>      ;yields {ty}:result,nuw=No Unsigned Wrap,poison if overflow
<result> = add nsw <ty> <op1>, <op2>      ;yields {ty}:result,nsw=No Signed Wrap,poison if overflow
<result> = add nuw nsw <ty> <op1>, <op2>  ;yields {ty}:result
;Example:
<result> = add i32 4, %var          ;yields {i32}:result = 4 + %var
#+END_SRC

** ~fadd~ Instruction

#+BEGIN_SRC llvm
;Syntax:
<result> = fadd <ty> <op1>, <op2>        ;yields {ty}:resul,ty is floating point/verctor of fp
<result> = fadd float 4.0, %var          ;yields {float}:result = 4.0 + %var
#+END_SRC

** ~sub~ and ~fsub~ Instruction
difference of its two operands,represent the ~neg~ instruction,~<result> = sub i32 0, %val~ yields ~{i32}:result = -%var~;~fsub~ Instruction(~fneg~)

** ~mul~ Instruction
*** _<result>_ unsigned overflow=>,<result> mod 2^n
*** If a full product (e.g. ~i32xi32->i64~) is needed, the operands should be sign-extended or zero-extended as appropriate to the width of the full product.  

** ~udiv~ Instruction
unsigned integer quotient,Division by zero leads to undefined behavior.for signed integer division, use ~sdiv~.

#+BEGIN_SRC llvm
;Syntax:
<result> = udiv <ty> <op1>, <op2>         ;yields {ty}:result
<result> = udiv exact <ty> <op1>, <op2>   ;yields {ty}:result,poison value if %op1 is not a multiple of %op2
#+END_SRC

** ~fdiv~ Instruction
#+BEGIN_SRC llvm
<result> = fdiv <ty> <op1>, <op2>         ;yields {ty}:result
#+END_SRC

** ~urem~ Instruction
~<result> = urem <ty> <op1>, <op2>~,unsigned integer remainder of a division,remainder of a division by zero leads to undefined behavior,for signed integer remainder, use ~srem~.

** ~srem~ Instruction
~<result> = srem <ty> <op1>, <op2>~,returns the remainder of a division (where the result is either zero or has the same sign as the dividend, op1)

** ~frem~ Instruction
returns the remainder of a division,the same sign as the dividend

** ~shl~ Instruction
returns ~op1*2^{op2} mod 2^n~; undef if ~op2(static/dynamic) <=0~ or ~>bitsof(op1)~

** ~lshr~ Instruction
logical shift right,undef if op2 ~> bitsof(op1)~. ~ashr~:arithmetic shift right
#+BEGIN_SRC llvm
<result> = lshr <ty> <op1>, <op2>
<result> = lshr exact <ty> <op1>, <op2>
#+END_SRC

** ~and~,~or~,~xor~ instruction

** ~ExtractElementInst~,~InsertElementInst~ and ~ShuffleVectorInst~
*** Vector Operations
*** ~<idx>~ can be variable(not constant)
 Aggregate Operations: ~ExtractValueInst~, ~InsertValueInst~; ~GetElementPtrInst~
#+BEGIN_SRC llvm
<result> = extractelement <n x <ty>> <val>, i32 <idx>    ; yields <ty>
<result> = extractelement <4 x i32> %vec, i32 0    ; yields i32

<result> = insertelement <n x <ty>> <val>, <ty> <elt>, i32 <idx>    ; yields <n x <ty>>
<result> = insertelement <4 x i32> %vec, i32 1, i32 0    ; yields <4 x i32>

<result> = shufflevector <n x <ty>> <v1>, <n x <ty>> <v2>, <m x i32> <mask>    ; yields <m x <ty>>
<result> = shufflevector <4 x i32> %v1, <4 x i32> %v2,
                         <4 x i32> <i32 0, i32 4, i32 1, i32 5>  ; yields <4 x i32>
<result> = shufflevector <4 x i32> %v1, <4 x i32> undef,
                         <4 x i32> <i32 0, i32 1, i32 2, i32 3>  ; yields <4 x i32> - Identity shuffle.
#+END_SRC

** ExtractValueInst~
*** ~ExtractValueInst~:~UnaryInstruction~
*** extracts the value of a member field from an aggregate value
*** ~<idx>~ should be constant(so is ~InsertValueInst~)
*** The major differences to ~getelementptr~ indexing are:
**** Since the value being indexed is not a pointer, the first index is omitted and assumed to be zero.
**** At least one index must be specified.
**** Not only struct indices but also array indices must be in bounds.
#+BEGIN_SRC llvm
<result> = extractvalue <aggregate type> <val>, <idx>{, <idx>}* #extracts the value of a member field
#+END_SRC

** ~InsertValueInst~
#+BEGIN_SRC llvm
<result> = insertvalue <aggregate type> <val>, <ty> <elt>, <idx>{, <idx>}*    # yields <aggregate type>
%agg1 = insertvalue {i32, float} undef, i32 1, 0              ; yields {i32 1, float undef}
%agg2 = insertvalue {i32, float} %agg1, float %val, 1         ; yields {i32 1, float %val}
%agg3 = insertvalue {i32, {float}} %agg1, float %val, 1, 0    ; yields {i32 1, float %val}
#+END_SRC

###~AllocaInst~
allocates ~sizeof(<type>)*NumElements~ bytes of memory on the stack frame of the currently executing function,returning a pointer of the appropriate type."NumElements" is defaulted to be 1;the value result of the allocation is guaranteed to be aligned to at least ~alignment~
#+BEGIN_SRC llvm
<result> = alloca <type>[, <ty> <NumElements>][, align <alignment>]     ;yields {type*}:result
%ptr = alloca i32                             
%ptr = alloca i32, i32 4                      
%ptr = alloca i32, i32 4, align 1024          
%ptr = alloca i32, align 1024                 
#+END_SRC

** ~LoadInst~
#+BEGIN_SRC llvm
<result> = load [volatile] <ty>* <pointer>[, align <alignment>][, !nontemporal !<index>][, !invariant.load !<index>]
<result> = load atomic [volatile] <ty>* <pointer> [singlethread] <ordering>, align <alignment> !<index> = !{ i32 1 }
%ptr = alloca i32                               ; yields {i32*}:ptr
store i32 3, i32* %ptr                          ; yields {void}
%val = load i32* %ptr                           ; yields {i32}:val = i32 3
#+END_SRC

** ~StoreInst~
#+BEGIN_SRC llvm
store [volatile] <ty> <value>, <ty>* <pointer>[, align <alignment>][, !nontemporal !<index>]        ; yields {void}
store atomic [volatile] <ty> <value>, <ty>* <pointer> [singlethread] <ordering>, align <alignment>  ; yields {void}

%ptr = alloca i32                               ; yields {i32*}:ptr
  store i32 3, i32* %ptr                          ; yields {void}
  %val = load i32* %ptr                           ; yields {i32}:val = i32 3
#+END_SRC

** ~FenceInst~
#+BEGIN_SRC llvm
fence [singlethread] <ordering>                   ; yields {void}
fence acquire                          ; yields {void}
fence singlethread seq_cst             ; yields {void}
#+END_SRC

** ~AtomicCmpXchgInst~
** ~AtomicRMWInst~
** ~GetElementPtrInst~
*** get the address of a subelement of an aggregate data structure
*** performs address calculation only and does not access memory.
#+BEGIN_SRC llvm
<result> = getelementptr <pty>* <ptrval>{, <ty> <idx>}*
<result> = getelementptr inbounds <pty>* <ptrval>{, <ty> <idx>}*
<result> = getelementptr <ptr vector> ptrval, <vector index type> idx 
; yields [12 x i8]*:aptr
%aptr = getelementptr {i32, [12 x i8]}* %saptr, i64 0, i32 1
; yields i8*:vptr
%vptr = getelementptr {i32, <2 x i8>}* %svptr, i64 0, i32 1, i32 1
; yields i8*:eptr
%eptr = getelementptr [12 x i8]* %aptr, i64 0, i32 1
; yields i32*:iptr
%iptr = getelementptr [10 x i32]* @arr, i16 0, i16 0
#+END_SRC

** ~TruncInst~
*** ~TruncInst~:~CastInst~
*** integer types or vector of int; 
*** ~ZExtInst~(:~CastInst~) and ~SExtInst~(:~CastInst~) are used to extend.
#+BEGIN_SRC llvm
<result> = trunc <ty> <value> to <ty2>
%X = trunc i32 257 to i8                        ; yields i8:1
%Y = trunc i32 123 to i1                        ; yields i1:true
%Z = trunc i32 122 to i1                        ; yields i1:false
%W = trunc <2 x i16> <i16 8, i16 7> to <2 x i8> ; yields <i8 8, i8 7>
#+END_SRC

** ~FPTruncInst~ and ~FPExtInst~
results are ~undef~ if ~value~ cannot fit within ~ty2~;size of ~value~ must be larger than the size of ~ty2~s
#+BEGIN_SRC llvm
<result> = fptrunc <ty> <value> to <ty2> 
%X = fptrunc double 123.0 to float         ; yields float:123.0
%Y = fptrunc double 1.0E+300 to float      ; yields undefined

%X = fpext float 3.125 to double         ; yields double:3.125000e+00
%Y = fpext double %X to fp128            ; yields fp128:0xL00000000000000004000900000000000
#+END_SRC

** ~FPToUIInst~,~FPToSIInst~
#+BEGIN_SRC llvm
<result> = fptoui <ty> <value> to <ty2>
%X = fptoui double 123.0 to i32      ; yields i32:123
%Z = fptoui float 1.04E+17 to i8     ; yields undefined:1

<result> = fptosi <ty> <value> to <ty2>
%X = fptosi double -123.0 to i32      ; yields i32:-123
%Y = fptosi float 1.0E-247 to i1      ; yields undefined:1
%Z = fptosi float 1.04E+17 to i8      ; yields undefined:1
#+END_SRC

** ~UIToFPInst~,~SIToFPInst~
#+BEGIN_SRC llvm
<result> = uitofp <ty> <value> to <ty2>
%X = uitofp i32 257 to float         ; yields float:257.0
%Y = uitofp i8 -1 to double          ; yields double:255.0

%X = sitofp i32 257 to float         ; yields float:257.0
%Y = sitofp i8 -1 to double          ; yields double:-1.0
#+END_SRC

** ~PtrToIntInst~, ~IntToPtrInst~
#+BEGIN_SRC llvm
%X = ptrtoint i32* %P to i8                         ; yields truncation on 32-bit architecture
%Y = ptrtoint i32* %P to i64                        ; yields zero extension on 32-bit architecture
%Z = ptrtoint <4 x i32*> %P to <4 x i64>; yields vector zero extension for a vector of addresses on 32-bit architecture

%X = inttoptr i32 255 to i32*          ; yields zero extension on 64-bit architecture
%Y = inttoptr i32 255 to i32*          ; yields no-op on 32-bit architecture
%Z = inttoptr i64 0 to i32*            ; yields truncation on 32-bit architecture
%Z = inttoptr <4 x i32> %G to <4 x i8*>; yields truncation of vector G to four pointers
#+END_SRC

** ~BitCastInst~
converts value to type ty2 without changing any bits;~ty1~ must also be a non-aggregate first class type.~bitos(value)==bitof(*ty2)~.
#+BEGIN_SRC llvm
%X = bitcast i8 255 to i8              ; yields i8 :-1
%Y = bitcast i32* %x to sint*          ; yields sint*:%x
%Z = bitcast <2 x int> %V to i64;        ; yields i64: %V
%Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>
#+END_SRC

** ~ICmpInst~:~CmpInst~
#+BEGIN_SRC llvm
<result> = icmp <cond> <ty> <op1>, <op2>
#possible cond:eq,ne;ugt,uge,ult,ule;sgt,sge,slt,sle
#+END_SRC

** ~FCmpInst~:~CmpInst~
#+BEGIN_SRC llvm
<result> = fcmp <cond> <ty> <op1>, <op2>
#possible cond:false,oeq,ogt,oge,olt,ole,one,ord,ueq,ugt,uge,ult,ule,une,uno,uno
#Ordered means that neither operand is a QNAN while unordered means that either operand may be a QNAN
#+END_SRC

** ~PHINode~
#+BEGIN_SRC llvm
<result> = phi <ty> [ <val0>, <label0>], ...

Loop:       ; Infinite loop that counts from 0 on up...
  %indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]
  %nextindvar = add i32 %indvar, 1
  br label %Loop
#+END_SRC

** ~SelectInst~
*** choose one value based on a condition, without branching
*** entire vectors are selected if val1/val2 are vectors and the condition is a scalar.
*** return 1st arg if ~cond~ is i1 and evaluates 1.
#+BEGIN_SRC llvm
<result> = select selty <cond>, <ty> <val1>, <ty> <val2>             ;; yields ty,selty is either i1 or {<N x i1>}
%X = select i1 true, i8 17, i8 42          ; yields i8:17
#+END_SRC

** ~CallInst~
represents a simple function call.
#+BEGIN_SRC llvm
<result> = [tail] call [cconv] [ret attrs] <ty> [<fnty>*] <fnptrval>(<function args>) [fn attrs]

%retval = call i32 @test(i32 %argc)
call i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42)        ; yields i32
%X = tail call i32 @foo()                                    ; yields i32
%Y = tail call fastcc i32 @foo()  ; yields i32
call void %foo(i8 97 signext)
#+END_SRC

*** ~tail~ indicates that callee does not access any allocas or varargs in the caller,present may be used for tail-call-optz
*** Similiar to ~InvokeInst~

** ~VaArgInst~
*** ~VaArgInst~:~UnaryInstruction~
*** used to access arguments passed through the "variable argument" area of a function call,implement the __va_arg__ macro in C;
returns a value of the specified argument type and increments the _va\_list_ to point to the next arg,actual type target specific.
#+BEGIN_SRC llvm
%struct.A = type { i32, i8 }
%r = call %struct.A @foo()                        ; yields { 32, i8 }
%gr = extractvalue %struct.A %r, 0                ; yields i32
%gr1 = extractvalue %struct.A %r, 1               ; yields i8
%Z = call void @foo() noreturn                    ; indicates that %foo never returns normally
%ZZ = call zeroext i32 @bar()                     ; Return value is %zero extended
#+END_SRC

** ~LandingPadInst~
used by LLVM's exception handling system to specify that a basic block is a landing pad(where the exception lands);corresponds to the code found in the catch portion of a try/catch sequence.

#+BEGIN_SRC llvm
<resultval> = landingpad <resultty> personality <type> <pers_fn> <clause>+
<resultval> = landingpad <resultty> personality <type> <pers_fn> cleanup <clause>*

<clause> := catch <type> <value>
<clause> := filter <array constant type> <array constant>
  
;; A landing pad which can catch an integer.
%res = landingpad { i8*, i32 } personality i32 (...)* @__gxx_personality_v0 catch i8** @_ZTIi
;; A landing pad that is a cleanup.
%res = landingpad { i8*, i32 } personality i32 (...)* @__gxx_personality_v0 cleanup
;; A landing pad which can catch an integer and can only throw a double.
%res = landingpad { i8*, i32 } personality i32 (...)* @__gxx_personality_v0 catch i8** @_ZTIi filter [1 x i8**] [@_ZTId]  
#+END_SRC
* Intrinsic Functions
** Notes: Intrinsic Functions represent an extension mechanism for the LLVM language that does not require changing all of the transformations in LLVM when adding to the language.
*** Names must begin with ~llvm.~
*** must always be external functions
*** may only be used in ~call~ or ~invoke~ instructions(illegal to take address)
*** intrinsic represents a family of functions that perform the same operation but on different data types can be overloaded

| Classification                | members                                                                                                                                                                       |
| Variable Argument Handling    | llvm.va_start,llvm.va_end,llvm.va_copy                                                                                                                                        |
| Accurate Garbage Collection   | Accurate Garbage Collection,llvm.gcread,llvm.gcwrite                                                                                                                          |
| Code Generator                | llvm.returnaddress,llvm.frameaddress,llvm.stacksave,llvm.stackrestore, llvm.prefetch,llvm.prefetch,llvm.readcyclecounter                                                      |
| Standard C Library            | Standard C Library,llvm.memmove,llvm.memset.*,llvm.sqrt.*,llvm.powi.*,llvm.sin.*,llvm.cos.*, llvm.pow.*,llvm.exp.*,llvm.log.*,llvm.fma.*',llvm.fabs.*,llvm.floor.* |
| Bit Manipulation              | llvm.bswap.*,llvm.ctpop.*,llvm.ctlz.*,llvm.cttz.*                                                                                                                         |
| Arithmetic with Overflow      | llvm.sadd.with.overflow.*,llvm.uadd.with.overflow.*,llvm.ssub.with.overflow.*,llvm.usub.with.overflow.*, llvm.smul.with.overflow.*,llvm.umul.with.overflow.*            |
| Specialised Arithmetic        | llvm.fmuladd.*                                                                                                                                                                |
| Half Precision Floating Point | llvm.convert.to.fp16,llvm.convert.from.fp16                                                                                                                                   |
| Debugger                      | [[http://llvm.org/docs/SourceLevelDebugging.html#format_common_intrinsics][LLVM Source Level Debugging]]                                                                                                                                                   |
| Exception Handling            | [[http://llvm.org/docs/ExceptionHandling.html#format_common_intrinsics][LLVM Exception Handling]]                                                                                                                                                       |
| Trampoline                    | llvm.init.trampoline,llvm.adjust.trampoline                                                                                                                                   |
| Memory Use Markers            | llvm.lifetime.start,llvm.lifetime.end,llvm.invariant.start,llvm.invariant.end                                                                                                 |
| General                       | llvm.var.annotation,llvm.annotation.*,llvm.trap,llvm.debugtrap,llvm.stackprotector,llvm.objectsize, llvm.expect,llvm.donothing                                               |

** ~llvm.va_start~, ~va_copy~, ~va_end~ Intrinsic
#+BEGIN_SRC llvm
;Syntax:
;initializes *<arglist> for subsequent use by va_arg,works like va_start macro in C,but does not need to know the last argument of the function as the compiler can figure that out
declare void %llvm.va_start(i8* <arglist>)
;destroys *<arglist> initialized previously with llvm.va_start or llvm.va_copy,works like the va_end macro in C
declare void @llvm.va_end(i8* <arglist>)
;copy argument position from src to dest
declare void @llvm.va_copy(i8* <destarglist>, i8* <srcarglist>)

;Example:
define i32 @test(i32 %X, ...) {
  ; Initialize variable argument processing
  %ap = alloca i8*
  %ap2 = bitcast i8** %ap to i8*
  call void @llvm.va_start(i8* %ap2)

  ; Read a single integer argument
  %tmp = va_arg i8** %ap, i32

  ; Demonstrate usage of llvm.va_copy and llvm.va_end
  %aq = alloca i8*
  %aq2 = bitcast i8** %aq to i8*
  call void @llvm.va_copy(i8* %aq2, i8* %ap2)
  call void @llvm.va_end(i8* %aq2)

  ; Stop processing of arguments.
  call void @llvm.va_end(i8* %ap2)
  ret i32 %tmp
}

declare void @llvm.va_start(i8*)
declare void @llvm.va_copy(i8*, i8*)
declare void @llvm.va_end(i8*)
#+END_SRC

** ~llvm.gcroot~ Intrinsic
*** Syntax: ~declare void @llvm.gcroot(i8** %ptrloc, i8* %metadata)~
*** declares the existence of a GC root to the code generator, and allows some metadata to be associated with it.
*** At runtime, a call to this intrinsic stores a null pointer into the ~ptrloc~ location.
*** At compile-time, the code generator generates information to allow the runtime to find the pointer at GC safe points.
*** may only be used in a function which specifies a GC algorithm

** ~llvm.gread~ Intrinsic
*** Syntax: ~declare i8* @llvm.gcread(i8* %ObjPtr, i8** %Ptr)~
*** reads of references from heap locations, allowing GC that require read barriers
*** has the same semantics as a load instruction, but may be replaced with substantially more complex code by GC
*** may only be used in a function which specifies a GC algorithm

** ~llvm.gwrite~ Intrinsic
*** Syntax: ~declare void @llvm.gcwrite(i8* %P1, i8* %Obj, i8** %P2)~
*** identifies writes of references to heap locations, allowing GC that require write barriers (generational or reference counting collectors)
*** same semantics as a store instruction, but may be replaced with substantially more complex code by GC
*** may only be used in a function which specifies a GC algorithm

** ~llvm.returnaddress~ Intrinsic
*** Syntax: ~declare i8  *@llvm.returnaddress(i32 <level>)~
*** compute a target-specific value indicating the return address of the current function or one of its callers
*** does not prevent function inlining/other aggressive transformations, so value returned may not be that of obvious source-language caller

** ~llvm.frameaddress~ Intrinsic
*** Syntax: ~declare i8* @llvm.frameaddress(i32 <level>)~
*** return the target-specific frame pointer value for the specified stack frame
*** does not prevent function inlining or other aggressive transformations

** ~llvm.stacksave~ Intrinsic
*** Syntax: ~declare i8* @llvm.stacksave()~
*** remember the current state of the function stack, for use with ~llvm.stackrestore~,useful for implementing language features like scoped automatic variable sized arrays in C99

** ~llvm.stackrestore'~ Intrinsic
*** Syntax: ~declare void @llvm.stackrestore(i8* %ptr)~
*** estore the state of the function stack to the state it was in when the corresponding llvm.stacksave intrinsic executed

** ~llvm.prefetch~ Intrinsic
*** Syntax: ~declare void @llvm.prefetch(i8* <address>, i32 <rw>, i32 <locality>, i32 <cache type>)~,~address~=address to be prefetched,~rw~ determining if the fetch should be for a read (0) or write (1),~locality~ is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache,~cache type~ specifies whether the prefetch is performed on the data (1) or instruction (0) cache.
*** a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a noop;change performance

** ~llvm.pcmarker~ Intrinsic
*** Syntax: ~declare void @llvm.pcmarker(i32 <id>)~
*** export a Program Counter (PC) in a region of code to simulators and other tools

** ~llvm.readcyclecounter'~ Intrinsic
*** Syntax: ~declare i64 @llvm.readcyclecounter()~
*** provides access to the cycle counter register (or similar low latency, high accuracy clocks) on those targets that support it

** ~llvm.memcpy.*~ Intrinsic
#+BEGIN_SRC llvm
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* <dest>, i8* <src>,
                                          i32 <len>, i32 <align>, i1 <isvolatile>)
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* <dest>, i8* <src>,
                                          i64 <len>, i32 <align>, i1 <isvolatile>)
#+END_SRC
*** can use llvm.memcpy on any integer bit width and for different address spaces. Not all targets support all bit widths.
*** unlike the standard libc function, the ~llvm.memcpy.*~ intrinsics do not return a value
*** If the ~isvolatile~ parameter is true, the llvm.memcpy call is a volatile operation. The detailed access behavior is not very cleanly specified and it is unwise to depend on it.
*** If the call to this intrinsic has an alignment value that is not 0 or 1, then the caller guarantees that both the source and destination pointers are aligned to that boundary.
*** copy a block of memory from the source location to the destination location, which are not allowed to overlap

** ~llvm.memmove.*~ Intrinsic
#+BEGIN_SRC llvm
declare void @llvm.memmove.p0i8.p0i8.i32(i8* <dest>, i8* <src>,
                                           i32 <len>, i32 <align>, i1 <isvolatile>)
declare void @llvm.memmove.p0i8.p0i8.i64(i8* <dest>, i8* <src>,
                                           i64 <len>, i32 <align>, i1 <isvolatile>)
#+END_SRC
*** move a block of memory from the src to the dest,allows the two memory locations to overlap
*** do not return a value

** ~llvm.memset.*~ Instrisic
#+BEGIN_SRC llvm
declare void @llvm.memset.p0i8.i32(i8* <dest>, i8 <val>,
                                     i32 <len>, i32 <align>, i1 <isvolatile>)
declare void @llvm.memset.p0i8.i64(i8* <dest>, i8 <val>,
                                     i64 <len>, i32 <align>, i1 <isvolatile>)
#+END_SRC
*** fill a block of memory with a particular byte value
*** does not return a value and takes extra alignment/volatile arguments
*** destination can be in an arbitrary address space

** ~llvm.sqrt.*~,~powi.*~,~sin.*~,~cos.*~,~pow.*~,~exp.*~,~log.*~,~fabs.*~,~floor.*~ Instrisic
overloaded intrinsic, used on any floating point or vector of floating point type
#+BEGIN_SRC llvm
declare float     @llvm.sqrt.f32(float %Val)
declare double    @llvm.powi.f64(double %Val, i32 %power)
declare x86_fp80  @llvm.sin.f80(x86_fp80  %Val)
declare fp128     @llvm.cos.f128(fp128 %Val)
declare ppc_fp128 @llvm.pow.ppcf128(ppc_fp128  %Val, ppc_fp128 Power) #float point
declare float     @llvm.exp.f32(float  %Val)
declare double    @llvm.fma.f64(double %a, double %b, double %c) #(a*b)+c
declare x86_fp80  @llvm.fabs.f80(x86_fp80  %Val)
declare fp128     @llvm.floor.f128(fp128 %Val)
#+END_SRC

** ~llvm.bswap.*~ Instrisic
#+BEGIN_SRC llvm
declare i16 @llvm.bswap.i16(i16 <id>)
declare i32 @llvm.bswap.i32(i32 <id>)
declare i64 @llvm.bswap.i64(i64 <id>)
#+END_SRC
overloaded,used on any integer type that is an even number of bytes (i.e. BitWidth % 16 == 0),useful for performing operations on data that is not in the target's native byte orde.The llvm.bswap.i16 intrinsic returns an i16 value that has the high and low byte of the input i16 swapped.

** ~llvm.ctpop.*~ Instrisic
#+BEGIN_SRC llvm
declare i8 @llvm.ctpop.i8(i8  <src>)
declare i16 @llvm.ctpop.i16(i16 <src>)
declare i32 @llvm.ctpop.i32(i32 <src>)
declare i64 @llvm.ctpop.i64(i64 <src>)
declare i256 @llvm.ctpop.i256(i256 <src>)
declare <2 x i32> @llvm.ctpop.v2i32(<2 x i32> <src>)
#+END_SRC
overloaded,used on on any integer bit width, or on any vector with integer elements;counts the 1's in a variable, or within each element of a vector

** ~llvm.ctlz.*~ Instrisic
#+BEGIN_SRC llvm
declare i8   @llvm.ctlz.i8  (i8   <src>, i1 <is_zero_undef>)
declare i16  @llvm.ctlz.i16 (i16  <src>, i1 <is_zero_undef>)
declare i32  @llvm.ctlz.i32 (i32  <src>, i1 <is_zero_undef>)
declare i64  @llvm.ctlz.i64 (i64  <src>, i1 <is_zero_undef>)
declare i256 @llvm.ctlz.i256(i256 <src>, i1 <is_zero_undef>)
declase <2 x i32> @llvm.ctlz.v2i32(<2 x i32> <src>, i1 <is_zero_undef>)
#+END_SRC
*** The first argument is the value to be counted, any integer bit width, or any vector whose elements are integers.
*** The second argument must be a constant and is a flag to indicate whether the intrinsic should ensure that a zero as the first argument produces a defined result
*** counts the leading (most significant) zeros in a variable, or within each element of the vector
*** _src == 0_ then the result is the size in bits of the type of src if _is_zero_undef == 0_ and ~undef~ otherwise.

** ~llvm.cttz.*~ Instrisic
#+BEGIN_SRC llvm
declare i8   @llvm.cttz.i8  (i8   <src>, i1 <is_zero_undef>)
declare i16  @llvm.cttz.i16 (i16  <src>, i1 <is_zero_undef>)
declare i32  @llvm.cttz.i32 (i32  <src>, i1 <is_zero_undef>)
declare i64  @llvm.cttz.i64 (i64  <src>, i1 <is_zero_undef>)
declare i256 @llvm.cttz.i256(i256 <src>, i1 <is_zero_undef>)
declase <2 x i32> @llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_undef>)
#+END_SRC
- counts the trailing (least significant) zeros in a variable, or within each element of a vector
- If _src == 0_ then the result is the size in bits of the type of src if _is_zero_undef == 0_ and ~undef~ otherwise. 

** ~llvm.sadd.with.overflow.~, ~llvm.ssub.with.overflow.*~, ~llvm.smul.with.overflow.*~
** ~llvm.uadd.with.overflow.*~,~llvm.usub.with.overflow.*~, ~llvm.umul.with.overflow.*~
#+BEGIN_SRC llvm
declare {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)
declare {i16, i1} @llvm.usub.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} @llvm.smul.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} @llvm.umul.with.overflow.i64(i64 %a, i64 %b)
#+END_SRC
*** 1st element is computation, 2nd element is a bit specifying overflow result
*** The arguments (%a and %b) and the first element of the result structure may be of integer types of any bit width, but they must have the same bit width
*** The second element of the result structure must be of type i1. %a and %b

** ~llvm.fmuladd.*~ Instrisic
#+BEGIN_SRC llvm
Syntax:
declare float @llvm.fmuladd.f32(float %a, float %b, float %c)
declare double @llvm.fmuladd.f64(double %a, double %b, double %c)
Example:
#equivalent to the expression a * b + c, 
#except that rounding will not be performed between the multiplication and addition steps if the code generator fuses the operations
%0 = call float @llvm.fmuladd.f32(%a, %b, %c)
#+END_SRC

** ~llvm.convert.to.fp16~, ~llvm.convert.from.fp16~ Instrisic
#+BEGIN_SRC llvm
;Syntax:
;single precision floating point -> half precision floating point
declare i16 @llvm.convert.to.fp16(f32 %a)
;half precision floating point -> single precision floating point
declare f32 @llvm.convert.from.fp16(i16 %a)
#+END_SRC

** ~llvm.init.trampoline~, ~llvm.adjust.trampoline~ Instrisic

** ~llvm.lifetime.start~, ~llvm.lifetime.end~ Instrisic
#+BEGIN_SRC llvm
#before this point in the code, the value of the memory pointed to by ptr is dead
declare void @llvm.lifetime.start(i64 <size>, i8* nocapture <ptr>)
#after this point in the code, the value of the memory pointed to by ptr is dead
declare void @llvm.lifetime.end(i64 <size>, i8* nocapture <ptr>)
#+END_SRC

** ~llvm.invariant.start~, ~llvm.invariant.end~ Instrisic
#+BEGIN_SRC llvm
;until an llvm.invariant.end that uses the return value, the referenced memory location is constant and unchanging
declare {}* @llvm.invariant.start(i64 <size>, i8* nocapture <ptr>)
;1st arg match llvm.invariant.start
;2nd arg is a constant integer representing the size of the object, or -1 if it is variable sized and the third argument is a pointer to the object
declare void @llvm.invariant.end({}* <start>, i64 <size>, i8* nocapture <ptr>)
#+END_SRC

** ~llvm.var.annotation~ Instrisic
*** Syntax: ~declare void @llvm.var.annotation(i8* <val>, i8* <str>, i8* <str>, i32  <int>)~
*** 1st arg is a pointer to a value,2nd is a pointer to a global string,3rd is a pointer to a global string which is the source file name, 4th is line number
***  allows annotation of local variables with arbitrary strings

** ~llvm.annotation.*~ Instrisic
#+BEGIN_SRC llvm
declare i8 @llvm.annotation.i8(i8 <val>, i8* <str>, i8* <str>, i32  <int>)
declare i16 @llvm.annotation.i16(i16 <val>, i8* <str>, i8* <str>, i32  <int>)
declare i32 @llvm.annotation.i32(i32 <val>, i8* <str>, i8* <str>, i32  <int>)
declare i64 @llvm.annotation.i64(i64 <val>, i8* <str>, i8* <str>, i32  <int>)
declare i256 @llvm.annotation.i256(i256 <val>, i8* <str>, i8* <str>, i32  <int>)
#+END_SRC
*** Used on any integer bit width,returns the value of the first argument.
*** allows annotations to be put on arbitrary expressions with arbitrary strings

** ~llvm.trap~ Instrisic
*** Syntax: ~declare void @llvm.trap() noreturn nounwind~
*** target dependent trap instruction;~abort()~ if trap instruction not supported

** ~llvm.debugtrap~ Instrisic
*** Syntax: ~declare void @llvm.debugtrap() nounwind~
*** lowered to code which is intended to cause an execution trap with the intention of requesting the attention of a debugger

** ~llvm.stackprotector~ Instrisic
*** Syntax: ~declare void @llvm.stackprotector(i8* <guard>, i8** <slot>)~
*** takes the guard and stores it onto the stack at slot, slot is adjusted to ensure that it is placed on the stack before local variables

** ~llvm.objectsize~ Instrisic
#+BEGIN_SRC llvm
declare i32 @llvm.objectsize.i32(i8* <object>, i1 <min>)
declare i64 @llvm.objectsize.i64(i8* <object>, i1 <min>)
#+END_SRC
*** designed to provide information to the optimizers to determine at compile time whether
**** an operation (like memcpy) will overflow a buffer that corresponds to an object, or
**** that a runtime check for overflow isn't necessary
*** lowered to a constant representing the size of the object concerned,returns i32/i64 -1 or 0 (depending on the min argument) if size cannot be determined at compiler time

** ~llvm.expect~ Instrisic
#+BEGIN_SRC llvm 
declare i32 @llvm.expect.i32(i32 <val>, i32 <expected_val>)
declare i64 @llvm.expect.i64(i64 <val>, i64 <expected_val>)
#+END_SRC
*** lowered to the val
*** information about expected (the most probable) value of ~val~, which can be used by optimizers

** ~llvm.donothing~ Instrisic
#+BEGIN_SRC llvm
declare void @llvm.donothing() nounwind readnone
#+END_SRC
*** nothing, and it's removed by optimizers and ignored by codegen
*** only intrinsic that can be called with an invoke instruction
