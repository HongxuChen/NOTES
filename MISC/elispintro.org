#+OPTIONS: creator:nil
#+TITLE: An Instruction to Emacs Lisp

* chapter 01
* chapter 02
** Unlike =setq=, =defvar= would not change the value if it has already been defined.
#+BEGIN_SRC elisp
(defvar variable-name value
  "document string")
#+END_SRC

** =let= and =let*= bindings, =let*= has the same form except that it can reference variables defined earlier in VARLIST
#+BEGIN_SRC elisp
(let (bindings)
  body)
#+END_SRC
An example:
#+BEGIN_SRC elisp
(defun circle-area (radix)
  (let 
    ((pi 3.1415926) area) ;; the varlist, but area cannot use pi now
    (setq area (* pi  radix radix))
    (message "radius=%.2f, area=%.2f" radix area)))
(circle-area 2.0)
#+END_SRC
#+BEGIN_SRC elisp
(defun circle-area (radix)
  "calculate circle area with the radius of `RADIX'"
  (let*
      ((pi 3.1415926) (area (* pi radix radix))) ;; area can use pi now
    (message "radius=%.2f, area=%.2f" radix area)
    ))
(circle-area 3)
#+END_SRC
** lambda expression
#+BEGIN_SRC elisp
(lambda (argument-list)
  "document strings"
  body)
#+END_SRC
#+BEGIN_SRC elisp
(setq lambda_foo
      (lambda (name)
       (message "hello, %s" name) ))
(funcall lambda_foo "Emacser")
#+END_SRC
** control structure:
*** sequential: =progn=; no need to use it when in special environment like =defun=
*** conditional: =if= , =cond=
#+BEGIN_SRC elisp
(if condition
    then_case
  else_case)
#+END_SRC
#+BEGIN_SRC elisp
(cond
 (cond_case1 do-when-case-1)
 (cond_case2 do-when-case-2)
 ...
 (t do-when-none-meet)
 )
#+END_SRC
Example:
#+BEGIN_SRC elisp
(defun my/fib (n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (t (+ (my/fib (- n 1)) (my/fib (- n 2))))
        ))
(my/fib 19)
#+END_SRC
*** LOOP =WHILE=
#+BEGIN_SRC elisp
(defun my-fact (n)
  (let ((res 1))
    (while (> n 0)
      (setq res (* res n)
            n (- n 1)))
    res))
(my-fact 10)
#+END_SRC
** logic operation =or=, =and=, =not=;
=and= / =or= both has short-cut properties; =and= can be used to replace =when=, while =or= can be used to replace =unless=.
#+BEGIN_SRC elisp
(defun hello-world (&optional name)
  (or name (setq name "Emacser"))
  (message "hello, %s" name))
(hello-world)
(hello-world "Hongxu")
#+END_SRC
#+BEGIN_SRC elisp
(defun square-number-p (n)
  (and
   (>= n 0)
   (= (/ n (sqrt n)) (sqrt n))))
(square-number-p -1)
(square-number-p 25)
(square-number-p 1025) ;; wrong for this one
#+END_SRC

* chapter 03
** test function
#+BEGIN_SRC elisp
(integerp 1.)  ;;t
(integerp 1.0) ;;nil
(floatp 1.)  ;;nil
(floatp -0.0e+NaN) ;;t
(numberp 1)  ;;t
#+END_SRC
** comparison of numbers
#+BEGIN_SRC elisp
(setq foo (- (+ 1.0 1.0e-3) 1.0))
(setq bar 1.0e-3)
(= foo bar) ;;nil
#+END_SRC
#+BEGIN_SRC elisp
(setq foo (- (+ 1.0 1.0e-3) 1.0))
(setq bar 1.0e-3)
(defvar fuzzy-factor 10e-6)
(defun float-equal (x y)
  (or
   (and (= x 0) (= y 0))
   (< (/ (abs (- x y)) (max (abs x) (abs y))) fuzzy-factor)
   ))
(float-equal foo bar)
#+END_SRC
** conversion
**** integer->float:float
**** float->integer:truncate,floor,celling,round
** calculation
*** absolute value: =mod= and =%=
#+BEGIN_SRC elisp
(+ (% dividend divisor)
   (* (/ dividend divisor) divisor));; dividend
(+ (mod dividend divisor)
   (* (floor dividend divisor) divisor)) ;; dividend
#+END_SRC
*** sin,cos,tan,asin,acos,atan
*** sqrt,exp,log10,random
** variables: =most-positive-fixnum=, =most-negative-fixnum=

* chapter 04
#+BEGIN_SRC elisp
(logior (lsh 1 27) ?A)  ;; 134217793
?\M-A                   ;; 134217793
#+END_SRC
** test function: string-or-null-p, char-or-string-p
#+BEGIN_SRC elisp
(defun string-emptyp (str)
  (not) (string< "" str))
#+END_SRC
** constructor:make-string,string,substring,concat
#+BEGIN_SRC elisp
(make-string 5 ?x)
(string ?a ?b ?c)
(substring "0123456789" 3)
(substring "123456789" 3 5)
(substring "123456789" -3 -1)
#+END_SRC
** comparison of strings: char-equal(case-fold-search), string=/string-equal, string</string-less
** conversion functions
*** char-to-string, string-to-char
*** number-to-string, string-to-number
#+BEGIN_SRC elisp
(string-to-number "256")
(number-to-string 256)
(format "%#o" 256)
(format "%#x" 256)
#+END_SRC
#+BEGIN_SRC elisp
(defun number-to-bin-string (number)
  (require 'calculator)
  (let ((calculator-output-radix 'bin)
    (calculator-radix-grouping-mode nil))
  (calculator-number-to-string number)))
(number-to-bin-string 256)
#+END_SRC
*** concat, vconcat, append
#+BEGIN_SRC elisp
(concat '(?a ?b ?c ?d ?e))
(concat [?a ?b ?c ?d ?e])
(vconcat "abcde") ;; [97 98 99 100 101], string->vector
(append "abcde" nil) ;; (97 98 99 100 101), string->list
#+END_SRC
*** downcase, upcase; capitalize,upcase-initials
#+BEGIN_SRC elisp
(downcase "The cat in the hat") ;; "the cat in the hat"
(downcase ?X)    ;;120
(upcase "The cat in the hat") ;; "THE CAT IN THE HAT"
(upcase ?x)      ;;80
(capitalize "The CAT in tHe Hat")  ;; "The Cat In The Hat"
(upcase-initials "The CAT in the HAt")  ;; "The CAT In The HAt"
#+END_SRC
** format strings
** search and replace
*** string-match, match-data, match-beginning, match-end
#+BEGIN_SRC elisp
(string-match "2*" "232*3=696")  ;; 0
(string-match (regexp-quote "2*") "232*3=696")  ;; 2
(progn (string-match "3\\(4\\)" "01234567890123456789")
       (match-data))  ;;(3 5 4 5)
(let ((start 0))
  (while (string-match "34" "01234567890123456789" start)
    (princ (format "find at %d\n" (match-beginning 0)))
    (setq start (match-end 0)))) ;; update start
#+END_SRC
*** replace-match, replace-regex-in-string, subst-char-in-string
#+BEGIN_SRC elisp
(let ((str "01234567890123456789"))
  (string-match "34" str)
  (princ (replace-match "x" nil nil str 0))
  (princ "\n")
  (princ str))
#+END_SRC
* chapter 05
#+BEGIN_SRC elisp
'(1 . 2)
'(?a . 1)
'(1 . "a")
'(1 . nil)
'(nil nil)
'(nil . nil)
(read "(1 . 2)") ;; (1 . 2)
nil   ;; nil is not `cons cell'
'()
(car nil)
(cdr nil)
#+END_SRC
| type of list  | the CDR of last cons cell     |
|---------------+-------------------------------|
| true list     | nil                           |
| dotted list   | neither =nil= nor =cons cell= |
| circular list | point to previous cons cell   |
#+BEGIN_SRC elisp
'(1 2 3)   ;; (1 2 3), true list
'(1 2 . 3) ;; (1 2 . 3), dotted list
'(1 . #1= (2 3 . #1#))  ;; (1 2 3 . #1), circular list
'(1 . (2 . (3 . nil))) ;;(1 2 3)
#+END_SRC
** test function
#+BEGIN_SRC elisp
(consp '(1 . 2))  ;;t
(consp '(1 . (2 . nil))) ;; t
(consp nil)  ;;nil
(listp '(1 . 2))  ;;t
(listp '(1 . (2 . nil))) ;;t
(listp nil)  ;;t
#+END_SRC
** constructors
#+BEGIN_SRC elisp
(cons 1 2) ;;(1 . 2)
(cons 1 '());;(1)
(cons 1 '(nil))  ;; (1 nil)
(cons '(1 2) 3)
(progn (setq foo '(a b))
       (cons 'x foo))  ;;(x a b)
(progn (setq foo '(a b))
       (push 'x foo)
       foo)  ;;(x a b)
(list (+ 1 2) 3 4)  ;;(3 3 4)
'((+ 1 2) 3)  ;;((+ 1 2) 3)
(append '(a b) '(c)) ;;(a b c)
(cons '(a b) '(c)) ;;((a b) c)
(append '(a b) 'c)  ;;(a b . c)
(append [a b] "cd" nil) ;;(a b 99 100)
#+END_SRC
** use list as array
#+BEGIN_SRC elisp
(nth 3 '(2 4 6 8 10)) ;;8
(nthcdr 2 '(2 4 6 8 10)) ;;(6 8 10)
(last '(2 4 6 8 10) 2) ;;(8 10)
(butlast '(2 4 6 8 10) 2) ;;(2 4 6)
(progn (setq foo '(a b c) ;; (a b c)
             (setcar foo 'x)
             foo  ;;(x b c)
             (setcdr foo '(o p q))
             foo  ;;(x o p q)
             ))
(progn (setq foo '(a b c))
       (setcdr foo foo)) ;;(a . #0)
(progn (setq foo '(1 2 3))
       (setcar foo 'a)
       (setcar (cdr foo) 'b)
       foo  ;; (a b 3)
       (setcar (nthcdr 2 foo) 'c)
       foo  ;;(a b c)
       )
#+END_SRC
** use list as stack/heap
#+BEGIN_SRC elisp
(setq foo nil)
(push 'a foo)
(push 'b foo)
(pop foo)
foo ;; (a)
#+END_SRC
** rearrange list
#+BEGIN_SRC elisp
(setq foo '(a b c))
(reverse foo) ;;(c b a)
foo ;;(a b c)
(nreverse foo) ;;(c b a)
foo  ;;(a)
(setq foo '(3 2 4 1 5))
(sort foo '<) ;;(1 2 3 4 5)
foo  ;;(3 4 5)
#+END_SRC
** use list as set
*** union: =append=
*** delete duplicates: =delete-dups=
*** equality/remove/delete: 
**** =memq=, =remq=, =delq= (with =eq=)
**** =member=, =remove=,, =delete= (with =equal=)
#+BEGIN_SRC elisp
(setq foo '(a b c))
(remq 'b foo)  ;;(a c)
foo            ;;(a b c)
(delq 'b foo)  ;;(a c)
foo            ;;(a c)
#+END_SRC

** use list as association list
 hash table VIRSUS association list
|                   | hash table | association list   |
|-------------------+------------+--------------------|
| key               | no order   | ordered            |
| functions         | maphash    | all list functions |
| read/input syntax | no         | yes                |
#+BEGIN_SRC elisp
(assoc "a" '(("a" 97) ("b" 98))) ;;("a" 97)
(setq a_v(assq 'a '((a . 97) (b . 98)))) ;;(a . 97)
(cdr (assoc "a" '(("a" 97) ("b" 98))))  ;;(97)
(cdr a_v) ;;(97)
(assoc-default "a" '(("a" 97) ("b" 98))) ;;(97)
(rassoc '(97) '(("a" 97) ("b" 98)))        ;;("a" 97)
(rassq '97 '((a . 97) (b . 98))) ;;(a . 97)
#+END_SRC
#+BEGIN_SRC elisp
(setq foo '(("a" . 97) ("b" . 98)))
;; update value by setcdr
(if (setq bar (assoc "a" foo))
    (setcdr bar "this is a")
  (setq foo (cons '("a" . "this is a") foo)))
foo
;; update value by delq and cons
(setq foo (cons '("a" . "this is a")
                (delq (assoc "a" foo) foo)))
#+END_SRC
** use list as tree
** traverse list
#+BEGIN_SRC elisp
(setq mylist '(1 2 3))
(mapc '1+ mylist)  ;;(1 2 3)
(mapcar '1+ mylist) ;;(2 3 4)
mylist ;;(1 2 3)

(dolist (foo '(1 2 3))
  (incf foo))  ;;nil
(setq bar nil)
(dolist (foo '(1 2 3) bar)
  (push (incf foo) bar)) ;;(4 3 2)
#+END_SRC
** other functions
*** filter:remove-if,remove-fi-not(=cl=)
#+BEGIN_SRC elisp
(defun my-remove-if (predicate list)
  (delq nil (mapcar
             (lambda (n)
               (and (not (funcall predicate n)) n))
             list)))
(defun evenp (n)
  (= (% n 2) 0))
(my-remove-if 'evenp '(0 1 2 3 4 5))
#+END_SRC
#+BEGIN_SRC elisp
(defun my-fold-left (op initial list)
  (dolist (var list initial)
    (setq initial (funcall op initial var))))
(my-fold-left '+ 0 '(1 2 3 4)) ;; 10
#+END_SRC
*** split-string, mapconcat, identity
#+BEGIN_SRC elisp
(split-string "key = val" "\\s-*=\\s-*")  ;; ("key" "val")
(mapconcat 'identity '("a" "b" "c") "_\t")  ;;"a_    b_    c"
#+END_SRC
** Q&A
*** write a self-defined nthcdr
#+BEGIN_SRC elisp
;; TODO verify it is wrong in elispintro.pdf
(defun my-nthcdr (n list)
  (if (or (null list) (= n 0))
      (cdr list)
    (my-nthcdr (1- n) (cdr list))))
(setq my-list '(9 8 7 6))
(setcar (my-nthcdr 1 my-list) 3)
my-list  ;;(9 8 3 6)
#+END_SRC
*** define my-subseq
#+BEGIN_SRC elisp
(defun my-subseq (list from &optional to)
                       (if (null to)
                           (nthcdr from list)
                         (butlast (nthcdr from list) (- (length list) to))))

(my-subseq '(1 2 3 4 5 6) 2 4) ;;(3 4)
#+END_SRC

* chapter 06
* chapter 07
* chapter 08
* chapter 09
* chapter 10
* chapter 11
* chapter 12
* chapter 13





