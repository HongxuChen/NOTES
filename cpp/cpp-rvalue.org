#+OPTIONS: TOC:nil

Basically referred to [[http://thbecker.net/articles/rvalue_references/section_01.html][C++ Rvalue References Explained]]

* No-Name Rule
The insight: the lifespan of the variable in the right-hand-side
- If it does not have a name, it's an **rvalue**.
- If it has a name, then it's an **lvalue**.

* Reference Collapsing Rules
  #+BEGIN_SRC
A& & becomes A&
A& && becomes A&
A&& & becomes A&
A&& && becomes A&&
  #+END_SRC

* Template Argument Deduction Rule
#+BEGIN_SRC c++
template<typename T>
void foo(T&&);
#+END_SRC
*** When foo is called on an lvalue of type A, T => A&
*** When foo is called on an rvalue of type A, T => A&&

* Move Semantics: std::move
#+BEGIN_SRC c++
template<typename _Tp>
constexpr typename std::remove_reference<_Tp>::type&& move(_Tp&& __t) noexcept {
  return static_cast<typename std::remove_reference<_Tp>::type&&>(__t);
}
#+END_SRC
*** Turns its argument into an rvalue even if it isn't
*** No name will be generated
*** only change the type for rvalue
#+BEGIN_SRC c++
X x;
std::move(x);
// is equavalent to
static_cast<X&&>(x);
#+END_SRC

* move semantics and exceptions
** For copy constructor and the copy assignment operator 
*** Write implementation so that they cannot throw exceptions
*** add noexcept keyword
** Example, for std::move and std::move_if_noexcept
#+BEGIN_SRC c++
#include <iostream>
#include <utility>
struct Bad {
  Bad() {}
  Bad(Bad&&) { std::cout << "Throwing move constructor called\n"; }
  Bad(const Bad&) { std::cout << "Throwing copy constructor called\n"; }
};
struct Good {
  Good() {}
  Good(Good&&) noexcept {
    std::cout << "Non-throwing move constructor called\n";
  }
  Good(const Good&) noexcept {
    std::cout << "Non-throwing copy constructor called\n";
  }
};
int main(void) {
  Good g1;
  Bad b1;
  Good g2 = std::move_if_noexcept(g1); // move
  Good g3 = std::move(g2);  // move
  Bad b2 = std::move_if_noexcept(b1); // copy
  Bad b3 = std::move(b2); // move
}
#+END_SRC

* rvalue is NOT always necessary
*** [[https://en.wikipedia.org/wiki/Return_value_optimization][RVO]](return value optimization) works better
*** moveable but not copyable -- **std::unique_ptr**
*** Implicit Move
*** Perfect Forwarding **std::forward**
#+BEGIN_SRC c++
template<typename _Tp>
  constexpr _Tp&&
forward(typename std::remove_reference<_Tp>::type& __t) noexcept {
  return static_cast<_Tp&&>(__t);
}
#+END_SRC
#+BEGIN_SRC c++
template<typename T, typename Arg>
shared_ptr<T> factory(Arg&& arg) {
 return shared_ptr<T>(new T(std::forward<Arg>(arg)));
}
/// remove_reference<S>::type& => S&
template<class S> S&& forward(typename remove_reference<S>::type& a) noexcept {
 return static_cast<S&&>(a);
}
#+END_SRC
**** For lvalue **X x**, **factory<A>(x);** becomes
#+BEGIN_SRC c++
shared_ptr<A> factory(X& && arg) {
 return shared_ptr<A>(new A(std::forward<X&>(arg)));
}
X& && forward(remove_reference<X&>::type& a) noexcept {
 return static_cast<X& &&>(a);
}
#+END_SRC
And finally
#+BEGIN_SRC c++
shared_ptr<A> factory(X& arg) {
 return shared_ptr<A>(new A(std::forward<X&>(arg)));
}
X& std::forward(X& a) {
 return static_cast<X&>(a);
}
#+END_SRC
**** For rvalue **X foo();**, **factory<A(foo());** becomes
#+BEGIN_SRC c++
shared_ptr<A> factory(X&& arg) {
 return shared_ptr<A>(new A(std::forward<X>(arg)));
}
X&& forward(X& a) noexcept {
 return static_cast<X&&>(a);
}
#+END_SRC

* Summary
*** Neither **std::move** nor **std::forward** does much, the rvalue reference semantics does.
*** [[http://www.artima.com/cppsource/rvalue.html][A Brief Introduction to Rvalue References]]
*** [[http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers][Universal References in C++11â€”Scott Meyers]]

* Rules of thumb:
*** Return by value (and rely on either copy elision or move semantics) unless you want to expose internals (like std::vector::operator[] returns a reference)
*** don't return an owning raw pointer (i.e. one that must be deleted)
*** don't return a const object (because that prohibits move semantics)
