* Strings
  #+BEGIN_SRC elisp
  (zerop (string-match "" "")) ;; O(n)  => t
  (string-equal "" "") ;; => t
  (equal "" "") ;; => t
  (zerop (length "")) ;; => t
  ;; nil prior Emacs23
  (eq "" "") ;; O(1) => t
  (eq "" (purecopy "")) ;; => t 
  (eq "" (propertize "" 'face 'italic)) ;; t
  #+END_SRC
** Strings vs buffer text
** Substrings
#+BEGIN_SRC elisp
(substring "abcdefg" 0 3)
(substring "abcdefg" -3 -1)
(substring "abcdefg" -3)
(with-temp-buffer (insert "abcdefg") (buffer-substring 2 4))
#+END_SRC
** starts-with and ends-with
#+BEGIN_SRC elisp
(defun string/ends-with (s ending)
  "return non-nil if string S ends with ENDING"
  (let ((elength (length ending)))
    (string= (substring s (- 0 elength)) ending)))
(defun string/starts-with (s arg)
  "return non-nil if string S starts with ARG. "
  (cond ((>= (length s ) (length arg))
         (string-equal (substring s 0 (length arg)) arg))
        (t nil)))
(and (string/starts-with "test" "te") (string/ends-with "test" "st"))

#+END_SRC
** Processing characters
#+BEGIN_SRC elisp
(reverse (string-to-list "foo"))
(apply #'string (reverse (string-to-list "foo")))

(setq test-str "abcdefg")
(setq test-str2 "")
(setq test-x 0)
(while (< test-x (length test-str))
  (setq test-str2 (concat test-str2 (char-to-string (elt test-str test-x))))
  (setq test-x (+ test-x 1)))

(apply 'string (mapcar '1- "foo")) ;; enn
(append "foo" nil)

;; cl solutions
(setq test-str "abcdefg")
(loop for x across test-str
      do (insert x))

(apply #'string (reverse (mapcar 'identity "1234")))
(concat (nreverse (append "1234" nil)))
#+END_SRC
*** string modification
#+BEGIN_SRC elisp
(capitalize "foo bar") ;; Foo Bar
(capitalize "speakerIt") ;; Speakerit
(upcase-initials "speakerIt") ;; SpeakerIt
(concat (capitalize (substring "foo bar" 0 1))
        (substring "foo bar" 1 (length "foo bar")))

(let ((input "foo bar"))
  (concat (capitalize (substring input 0 1))
          (substring input 1 (length input))))

(let ((table (copy-syntax-table text-mode-syntax-table)))
  (modify-syntax-entry ? "w" table) ;; IMPORTANT
  (with-syntax-table table
    (capitalize "foo bar"))) ;; Foo bar

(with-temp-buffer (insert "foo bar")
                  (goto-char (point-min)) (capitalize-word 1) (buffer-string))
#+END_SRC
*** strings are arrays
#+BEGIN_SRC elisp
(defvar my-string "foo")
(aref my-string 0) ;; 102 ?f
(aset my-string 0 ?b)
my-string ;; boo
#+END_SRC
#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "abcdefg")
  (goto-char (point-min))
  (while (not (= (char-after) ?b))
    (forward-char))
  (point)) ;; 2
#+END_SRC
** Trim whitespace
#+BEGIN_SRC elisp
(setq test-str "abcdefg\t")
;; string-match-p can only be used for test
(when (string-match "[ \t*$]" test-str)
  (message (concat "[" (replace-match "" nil nil test-str) "]")))
#+END_SRC
#+BEGIN_SRC elisp
(defun chomp (str)
  "chomping leading and tailing whitespace from STR"
  (while (string-match "\\`\n+\\|^\\s-+\\|\\s-+$\\|\n+\\'" str)
    (setq str (replace-match "" t t str)))
  str)
#+END_SRC
** Splitting strings
#+BEGIN_SRC elisp
(mapconcat 'identity '("" "home" "hongxu" ".emacs.d") "/")
#+END_SRC
** Serialization
#+BEGIN_SRC elisp
(length (read (prin1-to-string (make-list 100000 '(x)))))
(read (prin1-to-string (current-buffer))) ;; error
(read (prin1-to-string (make-hash-table))) ;; error before emacs23
#+END_SRC
** Formatting
print, princ, prin1; format, message; format-time-string

* Killing text
#+BEGIN_QUOTE 
Most of the kill commands are primarily for interactive use [â€¦] When you need to delete text for internal purposes within a Lisp function, you should normally use deletion functions, so as not to disturb the kill ring contents."
#+END_QUOTE
** Delete region
#+BEGIN_SRC elisp
(delete-region (region-beginning) (region-end))
#+END_SRC
** Delete line
#+BEGIN_SRC elisp
(let ((beg (point)))
      (forward-line 1)
      (forward-char -1)
      (delete-region beg (point)))
;; or
(delete-region (point)
               (progn
                 (forward-line 1)
                 (backward-char)
                 (point)))
;; or
(delete-region (point) (line-end-position))
#+END_SRC
** Delete line backwards
#+BEGIN_SRC elisp
(let ((beg (point)))
  (forward-line 0)
  (delete-region beg (point)))
;; progn won't take effect !
(delete-region (save-excursion (forward-line 0) (point)) (point))
(delete-region (line-beginning-position) (point))
#+END_SRC
** Delete line to next line
#+BEGIN_SRC elisp
;; `C-1 C-k`
(let ((beg (point)))
  (forward-line 1)
  (delete-region beg (point)
  ))
#+END_SRC
** Delete whole line
#+BEGIN_SRC elisp
;; kill-whole-line `C-S-backspace`
(let ((beg (progn (forward-line 0) (point))))
  (forward-line)
  (delete-region beg (point)))

(delete-region (progn (forward-line 0) (point))
               (progn (forward-line) (point)))

(delete-region (line-beginning-position) (line-end-position))
#+END_SRC
















** Delete word
** Delete sentence
#+BEGIN_SRC elisp
(delete-region (point) (forward-sentence) (point))
(delete-region (point) (save-excursion (forward-sentence) (point)))
(delete-region (point) (progn (forward-sentence) (point)))
#+END_SRC


* Numbers
** whether a string represents a number
#+BEGIN_SRC elisp
(defun string-interager-p (string)
  (if (string-match "\\`[-+]?[0-9]+\\'" string) t nil))

(defun string-float-p (string)
   (if (string-match "\\`[-+]?[0-9]+\\.[0-9]*\\'" string) t nil))

(string-interager-p "1234")
(string-float-p "3.141592653589793")
#+END_SRC
** String to number
#+BEGIN_SRC elisp
;; FIXME not right
(defun decimal-number (string)
  (let ((n (string-to-number string)))
    (save-match-data
      (if (and (not (zerop n))
               (string-match "\\`\\s-*0+\\.?0*\\s-*\\'" string))
          n
        nil))))
(decimal-number " 3.1415926 ")
#+END_SRC
** Random numbers
#+BEGIN_SRC elisp
(+ (random 6) 1)
#+END_SRC
** Commas in numbers
#+BEGIN_SRC elisp
(defun group-number (num &optional size char)
  "Format NUM as string grouped to SIZE with CHAR.
default value: SIZE 3, CHAR ,"
  (let* ((size (or size 3))
         (char (or char ","))
         (str (if (stringp num)
                  num
                (number-to-string num)))
         ;; TODO What does this mean?
         (pt (or (string-match "[^0-9a-zA-Z]" str) (length str))))
    (message "%d %s" pt str)
    (while (> pt size)
      (setq str (concat (substring str 0 (- pt size))
                        char
                        (substring str (- pt size)))
            pt (- pt size)))
    str))

(group-number 01234567)
(group-number "a1499787069" 4 " ")
(string-match "[^0-9a-zA-Z]" "a")
#+END_SRC
** Increment numbers
See [[http://www.emacswiki.org/emacs/IncrementNumber][EmacsWiki: Increment Number]]
** Dates and times
*** Todays's dates
#+BEGIN_SRC elisp
(message (format-time-string "now is %Y-%m-%d %T"))
(let ((time (date-to-time "Tue, 27-Sep-83 12:35:59 EST")))
  (set-time-zone-rule t)
  (prog1 (format-time-string "%Y-%m-%d %T CST" time)
    (set-time-zone-rule nil)))
(decode-time (date-to-time "Thu, 09-May-2013 23:46:19 UTC"))
(format-time-string "%j" (encode-time 0 0 0 44 1 2012))

(let ((time (date-to-time "13 Feb 2009 23:32:30 UTC")))
  (float-time time))

;; TODO time-zone issue, am I right here?
(format-time-string "%Y-%m-%d %T CST" (seconds-to-time 1234567890))

(format-time-string "%Y-%m-%d %T UTC" (time-add (current-time)
                                                  (seconds-to-time 30)))

(format-seconds "%Y %D %h:%m:%s" (1- (* 367 24 3600)))

(let ((days1 (time-to-days (date-to-time "Tue, 27-Sep-83 12:35:59 EST")))
        (days2 (time-to-days (date-to-time "2009-02-13 23:31:30 UTC"))))
    (- days2 days1))

(time-to-day-in-year (current-time))


#+END_SRC




