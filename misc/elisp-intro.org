[fn:1] Actually a PDF version.

* Hello world
* Fundamentals
** Unlike =setq=, =defvar= would not change the value if it has already been defined.
#+BEGIN_SRC elisp
(defvar variable-name value
  "document string")
#+END_SRC

** =let= and =let*= bindings, =let*= has the same form except that it can reference variables defined earlier in VARLIST
#+BEGIN_SRC elisp
(let (bindings)
  body)
#+END_SRC
An example:
#+BEGIN_SRC elisp
(defun circle-area (radix)
  (let 
    ((pi 3.1415926) area) ;; the varlist, but area cannot use pi now
    (setq area (* pi  radix radix))
    (message "radius=%.2f, area=%.2f" radix area)))
(circle-area 2.0)
#+END_SRC
#+BEGIN_SRC elisp
(defun circle-area (radix)
  "calculate circle area with the radius of `RADIX'"
  (let*
      ((pi 3.1415926) (area (* pi radix radix))) ;; area can use pi now
    (message "radius=%.2f, area=%.2f" radix area)
    ))
(circle-area 3)
#+END_SRC
** lambda expression
#+BEGIN_SRC elisp
(lambda (argument-list)
  "document strings"
  body)
#+END_SRC
#+BEGIN_SRC elisp
(setq lambda_foo
      (lambda (name)
       (message "hello, %s" name) ))
(funcall lambda_foo "Emacser")
#+END_SRC
** control structure:
*** sequential: =progn=; no need to use it when in special environment like =defun=
*** conditional: =if= , =cond=
#+BEGIN_SRC elisp
(if condition
    then_case
  else_case)
#+END_SRC
#+BEGIN_SRC elisp
(cond
 (cond_case1 do-when-case-1)
 (cond_case2 do-when-case-2)
 ...
 (t do-when-none-meet)
 )
#+END_SRC
Example:
#+BEGIN_SRC elisp
(defun my/fib (n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (t (+ (my/fib (- n 1)) (my/fib (- n 2))))
        ))
(my/fib 19)
#+END_SRC
*** LOOP =WHILE=
#+BEGIN_SRC elisp
(defun my-fact (n)
  (let ((res 1))
    (while (> n 0)
      (setq res (* res n)
            n (- n 1)))
    res))
(my-fact 10)
#+END_SRC
** logic operation =or=, =and=, =not=;
=and= / =or= both has short-cut properties; =and= can be used to replace =when=, while =or= can be used to replace =unless=.
#+BEGIN_SRC elisp
(defun hello-world (&optional name)
  (or name (setq name "Emacser"))
  (message "hello, %s" name))
(hello-world)
(hello-world "Hongxu")
#+END_SRC
#+BEGIN_SRC elisp
(defun square-number-p (n)
  (and
   (>= n 0)
   (= (/ n (sqrt n)) (sqrt n))))
(square-number-p -1)
(square-number-p 25)
(square-number-p 1025) ;; wrong for this one
#+END_SRC

* Numbers
** test function
#+BEGIN_SRC elisp
(integerp 1.)  ;;t
(integerp 1.0) ;;nil
(floatp 1.)  ;;nil
(floatp -0.0e+NaN) ;;t
(numberp 1)  ;;t
#+END_SRC
** comparison of numbers
#+BEGIN_SRC elisp
(setq foo (- (+ 1.0 1.0e-3) 1.0))
(setq bar 1.0e-3)
(= foo bar) ;;nil
#+END_SRC
#+BEGIN_SRC elisp
(setq foo (- (+ 1.0 1.0e-3) 1.0))
(setq bar 1.0e-3)
(defvar fuzzy-factor 10e-6)
(defun float-equal (x y)
  (or
   (and (= x 0) (= y 0))
   (< (/ (abs (- x y)) (max (abs x) (abs y))) fuzzy-factor)
   ))
(float-equal foo bar)
#+END_SRC
** conversion
**** integer->float:float
**** float->integer:truncate,floor,celling,round
** calculation
*** absolute value: =mod= and =%=
#+BEGIN_SRC elisp
(+ (% dividend divisor)
   (* (/ dividend divisor) divisor));; dividend
(+ (mod dividend divisor)
   (* (floor dividend divisor) divisor)) ;; dividend
#+END_SRC
*** sin,cos,tan,asin,acos,atan
*** sqrt,exp,log10,random
** variables: =most-positive-fixnum=, =most-negative-fixnum=

* Character and String
#+BEGIN_SRC elisp
(logior (lsh 1 27) ?A)  ;; 134217793
?\M-A                   ;; 134217793
#+END_SRC
** test function: string-or-null-p, char-or-string-p
#+BEGIN_SRC elisp
(defun string-emptyp (str)
  (not) (string< "" str))
#+END_SRC
** constructor:make-string,string,substring,concat
#+BEGIN_SRC elisp
(make-string 5 ?x)
(string ?a ?b ?c)
(substring "0123456789" 3)
(substring "123456789" 3 5)
(substring "123456789" -3 -1)
#+END_SRC
** comparison of strings: char-equal(case-fold-search), string=/string-equal, string</string-less
** conversion functions
*** char-to-string, string-to-char
*** number-to-string, string-to-number
#+BEGIN_SRC elisp
(string-to-number "256")
(number-to-string 256)
(format "%#o" 256)
(format "%#x" 256)
#+END_SRC
#+BEGIN_SRC elisp
(defun number-to-bin-string (number)
  (require 'calculator)
  (let ((calculator-output-radix 'bin)
    (calculator-radix-grouping-mode nil))
  (calculator-number-to-string number)))
(number-to-bin-string 256)
#+END_SRC
*** concat, vconcat, append
#+BEGIN_SRC elisp
(concat '(?a ?b ?c ?d ?e))
(concat [?a ?b ?c ?d ?e])
(vconcat "abcde") ;; [97 98 99 100 101], string->vector
(append "abcde" nil) ;; (97 98 99 100 101), string->list
#+END_SRC
*** downcase, upcase; capitalize,upcase-initials
#+BEGIN_SRC elisp
(downcase "The cat in the hat") ;; "the cat in the hat"
(downcase ?X)    ;;120
(upcase "The cat in the hat") ;; "THE CAT IN THE HAT"
(upcase ?x)      ;;80
(capitalize "The CAT in tHe Hat")  ;; "The Cat In The Hat"
(upcase-initials "The CAT in the HAt")  ;; "The CAT In The HAt"
#+END_SRC
** format strings
** search and replace
*** string-match, match-data, match-beginning, match-end
#+BEGIN_SRC elisp
(string-match "2*" "232*3=696")  ;; 0
(string-match (regexp-quote "2*") "232*3=696")  ;; 2
(progn (string-match "3\\(4\\)" "01234567890123456789")
       (match-data))  ;;(3 5 4 5)
(let ((start 0))
  (while (string-match "34" "01234567890123456789" start)
    (princ (format "find at %d\n" (match-beginning 0)))
    (setq start (match-end 0)))) ;; update start
#+END_SRC
*** replace-match, replace-regex-in-string, subst-char-in-string
#+BEGIN_SRC elisp
(let ((str "01234567890123456789"))
  (string-match "34" str)
  (princ (replace-match "x" nil nil str 0))
  (princ "\n")
  (princ str))
#+END_SRC
* ~cons cell~ and ~list~
#+BEGIN_SRC elisp
'(1 . 2)
'(?a . 1)
'(1 . "a")
'(1 . nil)
'(nil nil)
'(nil . nil)
(read "(1 . 2)") ;; (1 . 2)
nil   ;; nil is not `cons cell'
'()
(car nil)
(cdr nil)
(cons 'a '(b c));; (a b c)
'(a . (b c));; (a b c)
#+END_SRC
| type of list  | the CDR of last cons cell     |
|---------------+-------------------------------|
| true list     | nil                           |
| dotted list   | neither =nil= nor =cons cell= |
| circular list | point to previous cons cell   |
#+BEGIN_SRC elisp
'(1 2 3)   ;; (1 2 3), true list
'(1 2 . 3) ;; (1 2 . 3), dotted list
'(1 . #1= (2 3 . #1#))  ;; (1 2 3 . #1), circular list
'(1 . (2 . (3 . nil))) ;;(1 2 3)
#+END_SRC
** test function
#+BEGIN_SRC elisp
(consp '(1 . 2))  ;;t
(consp '(1 . (2 . nil))) ;; t
(consp nil)  ;;nil
(listp '(1 . 2))  ;;t
(listp '(1 . (2 . nil))) ;;t
(listp nil)  ;;t
#+END_SRC
** constructors
#+BEGIN_SRC elisp
(cons 1 2) ;;(1 . 2)
(cons 1 '());;(1)
(cons 1 '(nil))  ;; (1 nil)
(cons '(1 2) 3)
(progn (setq foo '(a b))
       (cons 'x foo))  ;;(x a b)
(progn (setq foo '(a b))
       (push 'x foo)
       foo)  ;;(x a b)
(list (+ 1 2) 3 4)  ;;(3 3 4)
'((+ 1 2) 3)  ;;((+ 1 2) 3)
(append '(a b) '(c)) ;;(a b c)
(cons '(a b) '(c)) ;;((a b) c)
(append '(a b) 'c)  ;;(a b . c)
(append [a b] "cd" nil) ;;(a b 99 100)
#+END_SRC
** use list as array
#+BEGIN_SRC elisp
(nth 3 '(2 4 6 8 10)) ;;8
(nthcdr 2 '(2 4 6 8 10)) ;;(6 8 10)
(last '(2 4 6 8 10) 2) ;;(8 10)
(butlast '(2 4 6 8 10) 2) ;;(2 4 6)
(progn (setq foo '(a b c) ;; (a b c)
             (setcar foo 'x)
             foo  ;;(x b c)
             (setcdr foo '(o p q))
             foo  ;;(x o p q)
             ))
(progn (setq foo '(a b c))
       (setcdr foo foo)) ;;(a . #0)
(progn (setq foo '(1 2 3))
       (setcar foo 'a)
       (setcar (cdr foo) 'b)
       foo  ;; (a b 3)
       (setcar (nthcdr 2 foo) 'c)
       foo  ;;(a b c)
       )
#+END_SRC
** use list as stack/heap
#+BEGIN_SRC elisp
(setq foo nil)
(push 'a foo)
(push 'b foo)
(pop foo)
foo ;; (a)
#+END_SRC
** rearrange list
#+BEGIN_SRC elisp
(setq foo '(a b c))
(reverse foo) ;;(c b a)
foo ;;(a b c)
(nreverse foo) ;;(c b a)
foo  ;;(a)
(setq foo '(3 2 4 1 5))
(sort foo '<) ;;(1 2 3 4 5)
foo  ;;(3 4 5)
#+END_SRC
** use list as set
*** union: =append=
*** delete duplicates: =delete-dups=
*** equality/remove/delete: 
**** =memq=, =remq=, =delq= (with =eq=)
**** =member=, =remove=,, =delete= (with =equal=)
#+BEGIN_SRC elisp
(setq foo '(a b c))
(remq 'b foo)  ;;(a c)
foo            ;;(a b c)
(delq 'b foo)  ;;(a c)
foo            ;;(a c)
#+END_SRC

** use list as association list
 hash table VIRSUS association list
|                   | hash table | association list   |
|-------------------+------------+--------------------|
| key               | no order   | ordered            |
| functions         | maphash    | all list functions |
| read/input syntax | no         | yes                |
#+BEGIN_SRC elisp
(assoc "a" '(("a" 97) ("b" 98))) ;;("a" 97)
(setq a_v(assq 'a '((a . 97) (b . 98)))) ;;(a . 97)
(cdr (assoc "a" '(("a" 97) ("b" 98))))  ;;(97)
(cdr a_v) ;;(97)
(assoc-default "a" '(("a" 97) ("b" 98))) ;;(97)
(rassoc '(97) '(("a" 97) ("b" 98)))        ;;("a" 97)
(rassq '97 '((a . 97) (b . 98))) ;;(a . 97)
#+END_SRC
#+BEGIN_SRC elisp
(setq foo '(("a" . 97) ("b" . 98)))
;; update value by setcdr
(if (setq bar (assoc "a" foo))
    (setcdr bar "this is a")
  (setq foo (cons '("a" . "this is a") foo)))
foo
;; update value by delq and cons
(setq foo (cons '("a" . "this is a")
                (delq (assoc "a" foo) foo)))
#+END_SRC
** use list as tree
** traverse list
#+BEGIN_SRC elisp
(setq mylist '(1 2 3))
(mapc '1+ mylist)  ;;(1 2 3)
(mapcar '1+ mylist) ;;(2 3 4)
mylist ;;(1 2 3)

(dolist (foo '(1 2 3))
  (incf foo))  ;;nil
(setq bar nil)
(dolist (foo '(1 2 3) bar)
  (push (incf foo) bar)) ;;(4 3 2)
#+END_SRC
** other functions
*** filter:remove-if,remove-fi-not(=cl=)
#+BEGIN_SRC elisp
(defun my-remove-if (predicate list)
  (delq nil (mapcar
             (lambda (n)
               (and (not (funcall predicate n)) n))
             list)))
(defun evenp (n)
  (= (% n 2) 0))
(my-remove-if 'evenp '(0 1 2 3 4 5))
#+END_SRC
#+BEGIN_SRC elisp
(defun my-fold-left (op initial list)
  (dolist (var list initial)
    (setq initial (funcall op initial var))))
(my-fold-left '+ 0 '(1 2 3 4)) ;; 10
#+END_SRC
*** split-string, mapconcat, identity
#+BEGIN_SRC elisp
(split-string "key = val" "\\s-*=\\s-*")  ;; ("key" "val")
(mapconcat 'identity '("a" "b" "c") "_\t")  ;;"a_    b_    c"
#+END_SRC
** Q&A
*** write a self-defined nthcdr
#+BEGIN_SRC elisp
(defun my-nthcdr (n list)
  (if (= n 0) list
    (my-nthcdr (1- n) (cdr list))))
(setq my-list '(9 8 7 6))
(setcar (my-nthcdr 1 my-list) 3)
my-list  ;;(9 7 3 6)
#+END_SRC
*** define my-subseq
#+BEGIN_SRC elisp
(defun my-subseq (list from &optional to)
                       (if (null to)
                           (nthcdr from list)
                         (butlast (nthcdr from list) (- (length list) to))))

(my-subseq '(1 2 3 4 5 6) 2 4) ;;(3 4)
#+END_SRC

* ~seq~ and ~array~
all arrays have the features below:
- The index starts from 0 and access of some element is in constant time
- No way the change the length once created
- self-evaluated(no need of ~quote~)
- accessed by ~aref~, and set by ~aset~
  # TODO
** test functions: ~sequencep~, ~arrayp~, ~vectorp~, ~bool-vector-p~
** general list functions:
#+BEGIN_SRC elisp
(safe-length '(a . b))  ;;1
(length '(a . b)) ;; error
(safe-length '#1= (1 2 . #1#))  ;; 3
#+END_SRC
** array operations
#+BEGIN_SRC elisp
(vector 'foo 23 [bar baz] "rats");;[foo 23 [bar baz] "rats"]
(make-vector 9 'z)
(fillarray (make-vector 4 'z) 5)
(vconcat [a b c] "aa" '(foo (6 7)))
#+END_SRC
** Q&A
*** test whethere some list is circular list (TODO)
*** ~tr~ (TODO)
* Symbols
#+BEGIN_SRC elisp
(symbolp '+1) ;; nil
(symbolp '\+1) ;; t
(symbol-name '\+1) ;; "+1"
#+END_SRC
** create symbols
#+BEGIN_SRC elisp
(setq foo (make-vector 3 0))
(intern-soft "abc" foo) ;; nil
(intern "abc" foo) ;; abc
(intern-soft "abc" foo) ;; abc
foo  ;; [abc 0 0]

(intern-soft "abc") ;; nil
'abc  ;; abc
(intern-soft "abc") ;; abc
(intern-soft "abcd")
'#:abcd
(intern-soft "abcd") ;;nil

(intern-soft "abc" foo) ;; abc
(unintern "abc" foo);; t
(intern-soft "abc" foo) ;; nil

#+END_SRC
#+BEGIN_SRC elisp
(setq count 0)
(defun count-syms (s)
  (setq count (1+ count)))
(mapatoms 'count-syms)
count
(length obarray) ;; 1511
#+END_SRC

** constructs of symbols
A symbol is consisted of 4 parts: ~symbol-name~, ~symbol-value~, ~symbol-function~, ~symbol-plist~
#+BEGIN_SRC elisp
(set (intern "abc" foo) "I'm abc")
(symbol-value (intern "abc" foo))
#+END_SRC
#+BEGIN_SRC elisp
(fset (intern "abc" foo) (symbol-function 'car)) ;; #<subr car>
(funcall (intern "abc" foo) '(a . b)) ;; a
#+END_SRC
#+BEGIN_SRC elisp
(put (intern "abc" foo) 'doc "this is abc")
(get (intern "abc" foo) 'doc) ;; "this is abc"
(symbol-plist (intern "abc" foo)) ;; (doc "this is abc")
#+END_SRC
#+BEGIN_SRC elisp
(plist-get '(foo 4) 'foo) ;; 4
(plist-get '(foo 4 bad) 'bar) ;;nil
(setq my-plist '(foo 4 bar 3)) ;;(foo 4 bar 3)
(setq my-plist (plist-put my-plist 'foo 69)) ;;(foo 69 bar 3)
(setq my-plist (plist-put my-plist 'quax '(a))) ;; (foo 69 bar 3 quax (a))
#+END_SRC
** Q&A
*** Why ~obarray~ has more symbols that vector length?
*** delete element according to keyword of some assoc list
*** ~plist-get~, ~plist-put~ implementation #TODO
* Evaluation Rules
~form~ in elisp:
- self-evaluated: number, string, vector, t, nil
- symbol: nil \rightarrow void-variables
- list form: categoried into 3 according to 1st element, i.e. function call, macro call, special form
  #+BEGIN_SRC emacs-lisp
  (symbol-function 'car) ;; #<subr car>
  (fset 'first 'car) ;; car
  (fset 'erste 'first) ;; first
  (erste '(1 2 3)) ;; 1
  #+END_SRC
  In summary the evaluation rules are like:
  #+BEGIN_SRC emacs-lisp
  (defun (eval expr)
  (cond
  ((numberp expr) expr)
  ((stringp expr) expr)
  ((arrayp expr) (symbol-value expr))
  ((symbolp expr) (car expr))
  ((special-form-p (car expr)) (eval-special-form exp))
  ((fboundp (car expr)) (apply (car exp) (cdr exp)))
  (t (error "unkonwn expr: %S" expr))))
  #+END_SRC
  
* Variables
** buffer-local variables
*** ~make-variable-buffer-local~, ~make-local-variable~
*** ~with-current-buffer~, ~get-buffer~
*** ~local-buffer-p~
*** ~buffer-local-value~
#+BEGIN_SRC elisp
(setq foo "global foo")
(make-local-variable 'foo)
foo
(setq foo "local foo")
foo
(with-current-buffer "*Messages*" foo) ;; global foo
#+END_SRC
#+BEGIN_SRC elisp
(local-variable-p 'foo (get-buffer "*Messages*"));; nil
(with-current-buffer "*Messages*"
  (buffer-local-value 'foo (get-buffer (current-buffer))))
#+END_SRC
** scope of variables
variables: global variables, buffer-local variables, let-binded local variables, function argument list variables
#+BEGIN_SRC elisp
(defun binder(x) (foo 5))
(defun user () (list x))
(defun foo (ignore) (user))
(binder 10)
#+END_SRC
** other functions
~boundp~, ~default-boundp~, ~makeunbound~, ~kill-local-variable~, ~kill-all-local-variables~
** naming variables
*** ~-hook~
*** ~-function~ value is function
*** ~-functions~ value is function list
*** ~-flag~ nil/non-nil
*** ~-predicate~ judge nil or non-nil
*** ~-program/-command~ some program/shell command
*** ~-form~ form
*** ~-forms~ form list
*** ~-map~ key maps
* Functions and Commands
** syntax
#+BEGIN_SRC elisp
(defun float-equal (f1 f2 &optional err)
  (if err
      (setq err (abs err))
    (setq err 1.0e-6))
  (or
   (and (= f1 0) (= f2 0))
   (<
    (/ (abs (- f1 f2)) (max (abs f1) (abs f2)))
    err)))
(float-equal 2.0000 1.9999)
(float-equal 2.0000 1.9999 1.0e-3)
#+END_SRC

** docstring
** function call
~funcall~, ~apply~
#+BEGIN_SRC elisp
(funcall 'list 'x '(y) '(z)) ;; (x (y) (z))
(apply 'list 'x '(y) '(z))  ;; (x (y) z)
#+END_SRC
** macro
#+BEGIN_SRC elisp
(defmacro foo (arg)
  (list 'message "%d-%d" arg arg))
(defun bar (arg)
  (message "%d-%d" arg arg))
(let ((i 1))
  (foo (incf i)))
(let ((i 1))
  (bar (incf i)))
#+END_SRC
#+BEGIN_SRC elisp
`(a list of  ,(+ 2 3) elements) ;; (a list of 5 elements)
'(a list of  ,(+ 2 3) elements) ;; (a list of \, (+ 2 3) elements) 
(setq some-list '(2 3))
'(1 ,some-list 4 ,@some-list) ;;(1 (\, some-list) 4 (\,@ some-list))
`(1 ,some-list 4 ,@some-list) ;;(1 (2 3) 4 2 3)
#+END_SRC

** commands
** Q&A
*** traverse tree
*** switch major mode
#+BEGIN_SRC elisp
(defvar switch-major-mode-history nil)
(defun switch-major-mode (mode)
  (interactive
   (list
    (intern
     (completing-read "Switch to mode: "
                      obarray (lambda (s)
                                (and (fboundp s)
                                     (string-match "-mode$" (symbol-name s))))
                      t nil 'switch-major-mode-history))))
  (setq switch-major-mode-history (cons (symbol-name major-mode) switch-major-mode-history))
  (funcall mode))
#+END_SRC

* Regular Expression
* Buffer
** buffer-name
** current-buffer
#+BEGIN_SRC elisp
(set-buffer "*Messages*")
(message (buffer-name))
(progn
  (set-buffer "*Messages*")
  (message (buffer-name))) ;; "*Messages*"
#+END_SRC
#+BEGIN_SRC elisp
(save-current-buffer
  (set-buffer "*scratch*")
  (goto-char (point-min))
  (set-buffer "*Messages*"))
(save-excursion
  (set-buffer "*scratch*")
  (goto-char (point-min))
  (set-buffer "*Messages*"))
#+END_SRC

** ~get-buffer-create~, ~generate-new-buffer~, ~kill-buffer~, ~kill-buffer-query-function~, ~kill-buffer-hook~, ~buffer-live-p~, ~buffer-list~
** mark and position
#+BEGIN_SRC elisp
(setq foo (make-marker))
(set-marker foo (point))

(point-marker)
(copy-marker 20)
(copy-marker foo)
#+END_SRC
#+BEGIN_SRC elisp
(goto-char (point-min))
(forward-char 10)
(forward-char -10)
(forward-line 2)
(forward-word -2)
(backward-word 2)
#+END_SRC

** ~buffer-string~, ~buffer-substring~, ~char-before~, ~char-after~
** modify buffer contents:
- ~delete-char~, ~delete-backward-char~, ~delete-region~
- ~re-search-forward~, ~re-search-backward~
- ~replace-match~
** Q&A
*** show-region
*** makr-whole-sexp
*** oowrite-table-convert
* Window
** split window
#+BEGIN_SRC elisp
(selected-window)
(split-window)
(window-tree)
#+END_SRC
** delete window
#+BEGIN_SRC elisp
(setq foo (selected-window))
(delete-window)
(windowp foo)
(window-live-p foo)
#+END_SRC
** window configuration
#+BEGIN_SRC elisp
(setq foo (current-window-configuration))
(set-window-configuration foo)
#+END_SRC
** selete window
#+BEGIN_SRC elisp
(progn
  (setq foo (selected-window))
  (message "original window: %S" foo)
  (other-window 1)
  (message "current window: %S" (selected-window))
  ;; (select-window foo)
  ;; (message "back to window: %S" foo)
  )
#+END_SRC
~save-selected-window~, ~with-selected-window~
#+BEGIN_SRC elisp
(save-selected-window
  (select-window (next-window))
  (goto-char (point-min)))
#+END_SRC
** window size
#+BEGIN_SRC elisp
(window-height) ;; 22
(window-body-height) ;; 20
(window-width) ;; 139
(window-edges) ;;(0 21 142 43)
(window-inside-edges) (2 22 141 42)
(window-pixel-edges) ;;(0 378 1278 774)
(window-inside-pixel-edges) ;;(18 396 1269 756)
#+END_SRC
** window related buffer
#+BEGIN_SRC elisp
(window-buffer)
(window-buffer (next-window))
(get-buffer-window (get-buffer "*scratch*")) ;; nil?
(get-buffer-window-list (get-buffer "*scratch*")) ;; nil?
#+END_SRC
** change display region: ~set-window-start~, ~window-start~, ~pos-visible-window-p~
** Q&A
*** save window location info
*** improve save window function
* File
** open file process
** read/write
#+BEGIN_SRC elisp
(with-current-buffer
    (find-file-noselect "~/.vimrc")
  buffer-file-name)
(find-buffer-visiting "~/.vimrc")
(get-file-buffer "~/.emacs.d")
(get-file-buffer "~/.recentf")
#+END_SRC
~insert-file-contents~, ~write-region~
** file information
#+BEGIN_SRC elisp
(setq vimrc-file "~/.vimrc")
(file-exists-p vimrc-file)
(file-readable-p vimrc-file)
(file-executable-p "~/.emacs.d") ;; t
(format "%o" (file-modes vimrc-file)) ;; 664
(file-regular-p vimrc-file)
(file-directory-p vimrc-file)
(file-symlink-p vimrc-file) ;; "/home/hongxuchen/src/mine/dotfiles/_vimrc"
(file-truename vimrc-file) ;;"/home/hongxuchen/src/mine/dotfiles/_vimrc"
#+END_SRC

** modify file information
~rename-file~, ~copy-file~, ~delete-file~, ~make-directory~
~set-file-times~, ~set-file-modes~
** filename operations
#+BEGIN_SRC elisp
(file-name-base vimrc-file) ;; ".vimrc"
(file-name-directory vimrc-file) ;; "~/"
(file-name-nondirectory (file-truename vimrc-file));; "_vimrc"
(file-name-sans-extension "~/non-exist.tar.gz") ;; "~/non-exist.tar"
(file-name-sans-versions "~/non-exist.tar.gz~~") ;; "~/non-exist.tar.gz~"
(file-name-absolute-p "~chx") ;; t
(expand-file-name "~/non-exist.tar")
(expand-file-name "non-exist.tar") ;; append current-directory with file name
(file-relative-name "~/.emacs.d/non-exist.tar")
(file-name-as-directory "~/non-exist.tar")
#+END_SRC

** make temp files
#+BEGIN_SRC elisp
(make-temp-name "../foo") ;; ../foo20947FU
(make-temp-name "../foo")
#+END_SRC

** read directory files
** handle
#+BEGIN_SRC text
'access-file', 'add-name-to-file', 'byte-compiler-base-file-name',
'copy-file', 'delete-directory', 'delete-file',
'diff-latest-backup-file', 'directory-file-name', 'directory-files',
'directory-files-and-attributes', 'dired-call-process',
'dired-compress-file', 'dired-uncache',
'expand-file-name', 'file-accessible-directory-p', 'file-attributes',
'file-name-all-completions', 'file-name-as-directory',
'file-name-completion', 'file-name-directory', 'file-name-nondirectory',
'file-name-sans-versions', 'file-newer-than-file-p',
'file-ownership-preserved-p', 'file-readable-p', 'file-regular-p',
'file-symlink-p', 'file-truename', 'file-writable-p',
'find-backup-file-name', 'find-file-noselect',
'get-file-buffer', 'insert-directory', 'insert-file-contents',
'load', 'make-auto-save-file-name', 'make-directory',
'make-directory-internal', 'make-symbolic-link',
'rename-file', 'set-file-modes', 'set-file-times',
'set-visited-file-modtime', 'shell-command', 'substitute-in-file-name',
'unhandled-file-name-directory', 'vc-registered',
'verify-visited-file-modtime',
'write-region'.
#+END_SRC
** Q&A
*** extract header file
*** emulate ~chmod~
*** my-directory-files
